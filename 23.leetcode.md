- ### 1.两数之和

  这里用到了vector，是容器的意思，相当于一个数组而且里面什么数据类型都能放。

  声明用vector<int> a

  往里面加元素用a.push_back()，随便加什么都行

  a.size()即为长度，即元素的个数

  访问的话和数组一样用a[]就行

  **普通数组的长度用sizeof(a)/sizeof(a[0])，这样表示**

  - 遍历穷举

    ```c++
    class Solution
    {
      public:
      vector<int> twoSum(vector<int> num,int target)
      {
        vector<int> a;
        for(int i=0;i<num.size();i++)
        {
          for(int j=i+1;j<num.size();j++)
          {
            if(num[i]+num[j]==target)
            {
              a.push_back(i);
              a.push_back(j);
            }
          }
        }
        return a;
      }
  };
    ```
  
    时间复杂度为O(n^2)，时间复杂度过高，因此尝试改进

  - 使用哈希方式

    ```c++
    class Solution 
    {
        public:
        vector<int> twoSum(vector<int> nums, int target) 
        {
            unordered_map<int,int> m;
            vector<int> rec;
            for(int i=0;i<nums.size();i++)
                m[nums[i]]=i;   //把所有的元素都放到哈希表里，key即为数，value为数在nums中的顺序数，m即给定一个数即nums[i]就可以得到它的value即顺序数i
            for(int i = 0 ; i < nums.size() ; i ++)
            {
                int t = target - nums[i];
                if(m.count(t)&&m[t]!=i)   //count(t)作用是看map中键值t的个数，就是看键值t在map中存不存在，因为key是不能重复的，因此count函数的值要么是0，要么是1.同时题目中要求一个数不能用两次，因此这个t的顺序数不能和i一样
                {
                     rec.push_back(i);
                     rec.push_back(m[t]);
                     break;
                }
            }
            return rec;
         }
  };
    ```
  
    使用了unordered_map<int,int> m定义了一个名为m的关键字和值都为int的哈希表，哈希就是给定一个关键字key能够找到对应的value值。key不能重复，但是不同的key可能会有相同的value就是所谓的冲突。

- ### 2.两数相加

  定义链表的结构体

  ```c++
  struct ListNode
  {
      int val;
      ListNode *next;
      ListNode(int x):val(x),next(NULL){}   //相当于是构造函数，用来新建一个节点
  }
  ```
  
  > 新建链表先使用`ListNode *p=new ListNode(x)`新建了一个val为x的节点且后驱指针为空，同时指针p指向它，然后`ListNode *l1=p`,然后将p作为索引指针一直移动往后插节点，l1不动，那么最后l1就指代这个链表，因为它指向链表的头节点的位置
  
  定义一个变量来记录进位，同时记住最后加完之后还要再下进位是否为1，是的话再加个1.
  
  ```c++
  /**
   * Definition for singly-linked list.
   * struct ListNode {
   *     int val;
   *     ListNode *next;
   *     ListNode(int x) : val(x), next(NULL) {}
   * };
   */
  class Solution {
  public:
      ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) 
      {
          ListNode *l3=new ListNode(0);
          ListNode *w=l3;
          int sum=0,carry=0;
          while(l1!=NULL||l2!=NULL)
          {
              if(l1!=NULL)
              {
                  sum+=l1->val;
                  l1=l1->next;
              }
              if(l2!=NULL)
              {
                  sum+=l2->val;
                  l2=l2->next;
              }
              w->next=new ListNode((sum+carry)%10);
              w=w->next;
              carry=(sum+carry>9)?1:0; 
              sum=0;           
          }
          if(carry==1)
          {
              w->next=new ListNode(1);
          }
          return l3->next;        
      }
  };
  ```
  
- ### 7.整数反转

  > 将一个给定的32位有符号整数，将数字每位上的整数进行反转。

  用x%10取出x的最后一位，设为pop。翻转后的数字用ans存贮，ans默认为0，然后通过ans=ans*10+x%10来不断迭代。

  还有个要注意的就是溢出问题，int是4个字节即32位，有符号的话INT_MAX即2的32次方减一即2147483647，同样得出INT_MIN。不能溢出也就是不能比max大不能比min小。

  溢出即ans*10+pop>INT_MAX，有两种可能：

  - ans>INT_MAX/10
  - ans==INT_MAX/10且pop>7(这里的7即为MAX的个位数)
  
  同样可以得出小于min的溢出条件。（注意32位有符号整数表示的范围用的是补码的范围，而且溢出了程序也不会报错，只是把多余的位数去掉，输出剩下的位数在可表示范围内对应的数，只是这个数并不是我们正确的计算结果，因此不能在ans=ans*10+pop之后再用ans>INT_MAX来判断，因为在int里不会有比他大的数，这样比较永远不知道是否溢出，因此就要在ans乘10之前就要确定它乘了之后会不会溢出）
  
  ```c++
  class Solution {
  public:
      int reverse(int x) 
      {
          int ans=0;
          while(x)
          {
              int pop=x%10;    //这儿可以直接用表达式x%10代表pop，省去pop的空间，进一步削减空间复杂度
              if(ans>INT_MAX/10||ans==INT_MAX/10&&pop>7)
                  return 0;
              if(ans<INT_MIN/10||ans==INT_MIN/10&&pop<-8)
                  return 0;
              ans=ans*10+pop;
              x/=10;
          }   
          return ans;     
      }
  };
  ```
  
- ### 9.回文数

  负数和能够整除10（除了0）都不行

  - 第一种利用类似于上面翻转整数的方法，再判断一下溢出就性

    ```c++
    class Solution {
    public:
        bool isPalindrome(int x) 
        {
            if(x<0)
                return false;
            int m=x,ans=0;
            while(m)
            {
                if(ans>INT_MAX/10||ans==INT_MAX/10&&m%10>7)
                    return 0;
                if(ans<INT_MIN/10||ans==INT_MIN/10&&m%10<-8)
                    return 0;
                ans=ans*10+m%10;
                m/=10;
            } 
            if(x==ans)
                return true;
            return false;        
        }
    };
    ```
    
  - 第二种换了种循环的判断方法，while(x > ans)。跳出循环后如果是原数有偶数个数字，那么x==ans就表明是回文数；如果有奇数个数字，那么跳出循环后x==ans/10就表明是回文数。

    > 这样不用像上面那样全部翻转完之后再比较，只需要翻转一半，而且不用判断溢出，因此时间复杂度更优秀
    
    ```c++
    class Solution 
    {
        public:
        bool isPalindrome(int x) 
         {
           if(x < 0||x%10==0&&x!=0) 
                 return false;
           int ans = 0;
             while(x > ans) 
             {
                ans = ans*10+x%10;
                x /= 10;
             }
             if(x == ans || x == ans/10)
                 return true;
             return false;
          }   
    };
    ```

- ### 13.罗马数字转整数

  要注意一个，要把string类型赋值给字符数组时，例如：

  - string s="abc"

    **char * a=const_cast<char *>(s.c_str())**

  - strlen()函数用来求取给定字符串或字符数组的长度

    char a[]={'a','b','\0'}  //字符数组求取长度必须后面加\0，否则结果出错

    char *a="abcd"

    char a[]="abcd"

    string s="abcd"

  - **length()用的时候是s.length();前面跟字符串。**s.size()效果一样

  - **sizeof()返回一个变量或者类型的大小，以字节为单位**

  - 暴力例举(太蠢了）

    ```c++
  class Solution {
    public:
      int romanToInt(string s) {
            char *a=const_cast<char*>(s.c_str());
            int sum=0;
            for(int i=0;i<strlen(a);i++)
            {
                if(a[i]=='I'&&a[i+1]!='V'&&a[i+1]!='X')
                    sum+=1;
                if(a[i]=='I'&&a[i+1]=='V')
                    sum+=4;
                if(a[i]=='I'&&a[i+1]=='X')
                    sum+=9;
                if(a[i]=='V'&&a[i-1]!='I')
                    sum+=5;
                if(a[i]=='X'&&a[i+1]!='L'&&a[i+1]!='C'&&a[i-1]!='I')
                    sum+=10;
                if(a[i]=='X'&&a[i+1]=='L')
                    sum+=40;
                if(a[i]=='X'&&a[i+1]=='C')
                    sum+=90;
                if(a[i]=='L'&&a[i-1]!='X')
                    sum+=50;
                if(a[i]=='C'&&a[i+1]!='D'&&a[i+1]!='M'&&a[i-1]!='X')
                    sum+=100;
                if(a[i]=='C'&&a[i+1]=='D')
                    sum+=400;
                if(a[i]=='C'&&a[i+1]=='M')
                    sum+=900;
                if(a[i]=='D'&&a[i-1]!='C')
                    sum+=500;
                if(a[i]=='M'&&a[i-1]!='C')
                    sum+=1000;
              }
          return sum;
         }
    };
    ```

  - 使用哈希方式，建立哈希表m对应每个字母与每个数字，依次遍历字符串的每个字符，当

    m[s[i]]>=m[s[i+1]]时直接加上s[i]，当m[s[i]]<m[s[i+1]]时，就生成组合，输出后一位减前一位的差，同时i自加1，即往后空一位。

    > **往unordered_map里插入数据可以用m.insert(pair<int,int>(10,10))**
    >
    > map内部实现了一个红黑树，是有序的；而unordered_map即哈希表，无序的
    
    ```c++
    class Solution
    {
        public:
        int romanToInt(string s)
        {
            int sum=0;
            unordered_map<char,int> m;(用map代替unordered_map也可以)
            m.insert(pair<char,int>('I',1));  //插入可以直接m['I']=1,还可以初始化的时候直接m={{'I',1},.........}
            m.insert(pair<char,int>('V',5));
            m.insert(pair<char,int>('X',10));
            m.insert(pair<char,int>('L',50));
            m.insert(pair<char,int>('C',100));
            m.insert(pair<char,int>('D',500));
            m.insert(pair<char,int>('M',1000));
            for(int i=0;i<s.length();i++)
            {
                if(m[s[i]]>=m[s[i+1]])
                    sum+=m[s[i]];
                else
                {
                    sum+=m[s[i+1]]-m[s[i]];
                    i++;
                }
            }
            return sum;
         }
    };
    ```

- ### 14.最长公共前缀

  以第一个字符串为标准，一个一个往后比较

  ```c++
  class Solution {
  public:
      string longestCommonPrefix(vector<string>& strs) 
      {
          if(strs.empty())
              return "";
          string s=strs[0];
          for(int i=1;i<strs.size();i++)
          {
              for(int j=0;j<s.size();j++)
              {
                  if(strs[i][j]==s[j])
                      continue;
                  else
                  {
                      s.erase(j);  //string的erase(i)，i是数字的话会删除从i开始后面所有的，如果i是迭代器的话只会删除i这个位置上的，即string:: iterator=it。！！！但是vector的话只能用迭代器erase删除指定位置或者指定区域
                      break;
                  }
              }
          }
          return s;        
      }
  };
  ```

- ### 3.无重复字符的最长字串的长度

  使用滑动窗口的办法，在字符和位置之间建立一个hash映射，初始建立m[256]={0},有256个元素，初始值全为零，256是因为ascii有256个。

  ```c++
  class Solution {
  public:
      int lengthOfLongestSubstring(string s) {
          int m[256]={0};//字符有256个,
          int left=0;//查找的左边界
          int mlen=0;//结果
          for(int i=0;i<s.length();i++)
          {
              if(m[s[i]]==0||m[s[i]]<=left)       //m[s[i]]=0证明没出现过，所以直接加进去（因此下面要用m[s[i]]=i+1,如果等于i的话第一个字符永远没出现过可以一直加，那后面就算重复出现也会当成没出现过，所以加个1，那么加1之后就表示的s[i]的位置的后一位），或者m[s[i]]<=left，即s[i]出现过但是m[s[i]]<=left即s[i]不在当前的窗口里，因此把他放进来
              {
                  mlen=max(mlen,i-left+1);
              }
              else
                  left=m[s[i]];  //else即表明s[i]在框里已经出现过了，因此就把left移动到上一个s[i]出现位置的下一个，然后下面再m[s[i]]=i+1,声明s[i]最新的位置的下一位
              m[s[i]]=i+1;    //m[s[i]]表示的是s[i]上次最新出现的位置的下一位，所有上面才有比较，看m[s[i]]是否为0或m[s[i]]是否在当前的框里
          }
          return mlen;
      }
  };
  ```
  
- ### 20.有效的括号

  思路就是从最内层的括号开始，一对一对的删除，看最后能不能都删除完，但是我们无法实直接从最里面开始删，因为不知道最里面的位置在哪儿，所以利用栈，通过递归的方式，遇到左括号就放进去，然后碰到右括号就依次和栈顶的比较。

  利用的STL中的stack，遇到左括号就压栈，然后遇到右括号就和栈顶的左括号比较，如果一样就把栈顶的左括号删除，如果不一样那么字符串无效。

  特别注意的是数组的越界问题，当栈为空时，stack.top()这种访问方式时非法无效的，因此当要用右括号和栈顶的元素比较之前要先看栈是否为空，如果为空，直接false。

  ```c++
  class Solution {
  public:
      bool isValid(string s)
      {
          if(s.size()%2!=0)         //如果字符串长度为奇数个，那么字符串必然无效
              return false;
          map<char,char> m;
          m.insert(pair<char,char>('(',')'));     //通过哈希建立左右括号的一一对应关系
          m.insert(pair<char,char>('[',']'));
          m.insert(pair<char,char>('{','}'));
          stack<char> n;
          for(int i=0;i<s.size();i++)
          {
              if(s[i]=='('||s[i]=='{'||s[i]=='[')
                  n.push(s[i]);
              else
              {
                  if(n.empty())         //这个判断是必须的，如果没有这个判断，当栈为空时，下面的n.top()就是越界非法访问
                      return false;
                  if(s[i]==m[n.top()])
                      n.pop();
                  else
                      return false;
              }
          }
          if(n.empty())
              return true;
          return false;
      }
  };
  ```
  
- ### 21.合并两个有序链表

  因为给的链表就是有序的，因此每次比较两个链表的表头元素，把小的插入到新的链表中。直到其中一个链表为空，然后把不为空的链表直接链接到新链表后面就行

  ```c++
  /**
   * Definition for singly-linked list.
   * struct ListNode {
   *     int val;
   *     ListNode *next;
   *     ListNode(int x) : val(x), next(NULL) {}
   * };
   */
  class Solution {
  public:
      ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) 
      {
          ListNode* l3=new ListNode(0);
          ListNode* p=l3;
          while(l1!=NULL&&l2!=NULL)
          {
              if(l1->val<=l2->val)
              {
                  p->next=new ListNode(l1->val);
                  p=p->next;
                  l1=l1->next;
              }
              else
              {
                  p->next=new ListNode(l2->val);
                  p=p->next;
                  l2=l2->next;           
              }  
          }
          if(l1==NULL)
              p->next=l2;
          else
              p->next=l1;
          return l3->next;
      }
  };
  ```

- ### 26.删除排序数组的重复项

  利用两个指针，一个慢指针留在前面保存数字，快指针向后一个一个遍历。

  - 如果慢指针等于快指针，证明是一样的数，那么慢指针不变，快指针向后加一然后再和慢指针比较
  - 如果不等，说明遇到新的数了，那么慢指针后移一位同时把当前快指针的值拷贝过来，然后快指针后移，继续比较。

  ```c++
  class Solution {
  public:
      int removeDuplicates(vector<int>& nums) 
      {
          if(nums.empty())
              return 0;
          int low=0;
          for(int i=0;i<nums.size();i++)
          {
              if(nums[i]!=nums[low])
                  nums[++low]=nums[i];
          }
          return low+1;
      }
  };
  ```

  还可以利用STL的unique函数配合erase函数

  ```c++
  class Solution {
  public:
      int removeDuplicates(vector<int>& nums) 
      {
          vector<int>::iterator it;
          it=unique(nums.begin(),nums.end()); //unique把范围内的元素折叠缩编，变成唯一的，但是并没有改变元素的个数，重复的元素就放到最后面，如[1,1,2,3,3]经过处理后就变成了[1,2,3,1,3],只是把顺序变了，同时unique函数返回一个指向第一个重复数字的迭代器，在这个例子中就返回一个指向第3个元素1的迭代器
          int b=0;
          while(it!=nums.begin())
          {
              b++;
              it--;
          }
          return b;
          //nums.erase(it,nums.end());
          //return nums.size();            这儿并没有要求要删除后面重复的元素，因此不用erase，如果要的话可以通过erase函数实现
      }
  };
  ```

- ### 27.移除元素

  和上题类似，也是利用了双指针的思想。慢指针记录!=val的数，快指针在前面找!=val的数然后传回来

  - 当==val时，不处理，计入下次循环，j++
  - 当!=val时，这是我们要的值， 这时两个指针同时自加1，然后把新出现的j指的值给i，继续遍历

  ```c++
  class Solution {
  public:
      int removeElement(vector<int>& nums, int val) 
      {
          int i=0;
          for(int j=0;j<nums.size();j++)
          {
              if(nums[j]!=val)
                  nums[i++]=nums[j];
          } 
          return i;
      }
  };
  ```
  
- ### 28.实现strStr()即在一个大字符串中匹配另一个小的字符串同时输出小字符串在大字符串中出现的第一个位置的索引

  - 自己写的，暴力比较，遍历大字符串，然后每遍历一次就和小字符串比较一次。但是时间复杂度贼高,而且字符串一长就会溢出。思想可以，但是实际不能用，选择放弃

    ```c++
    class Solution {
    public:
        int strStr(string haystack, string needle) 
        {
            if(needle.size()==0)
                return 0;
            int n=needle.size();
            int count=0;
            for(int i=0;i<haystack.size();i++)
            {
                for(int j=0;j<needle.size();j++)
                {
                    if(needle[j]==haystack[i+j])
                        count+=1;
                    else
                        break;
                }
                if(count==n)
                    return i;
                else
                    count=0;
            }
            return -1;
        }
    };
    ```

  - 直接用库函数中的find函数，a.find(b）直接就是结果

    ```c++
    class Solution {
    public:
        int strStr(string haystack, string needle) 
        {
            return haystack.find(needle);    //能找到的话会返回第一个元素的索引，找不到返回-1
      }
    };
    ```
    
    时间复杂度和空间复杂度都很低，但是没啥技术含量
  
- ### 35.搜索插入位置

  - ```c++
    class Solution {
    public:
        int searchInsert(vector<int>& nums, int target) 
        {
            for(int i=0;i<nums.size();i++)
            {
                if(nums[i]>=target)
                    return i;
            }
            return nums.size();
        }
    };
    ```

  - 折半查找。主要就是三个指针，head，mid和last，head=0，last=maxsize-1，然后mid初始设置为0，while（head<last)的时候循环，每次循环先设置mid=(last-head)/2+head.

    ```c++
    class Solution {
    public:
        int searchInsert(vector<int>& nums, int target) 
        {
            int head=0;
            int mid=0;
            int last=nums.size()-1;
            while(head<last)
            {
                mid=(last-head)/2+head;
                if(target>nums[mid])
                    head=mid+1;
                else if(target<nums[mid])  //这儿一定要注意要用else if而不要用if...if...else，前者是多个情况选一个，而后者是最后一格else只和最接近的if匹配，前面的if只要满足就执行，就算前面执行了后面的最后一格if else里总是还有一个也会执行。
                    last=mid-1;
                else
                    return mid;            
            }
            if(target<=nums[head])
                return head;
            return head+1;
        }
    };
    ```

- ### 38.外观数列

  利用的是递归的思想，题目的意思是从第二个开始（包括第二个），数字对应的字符串是用来描述上一个字符串的数字的。

  第一个是1，那么第二个就描述第一个，1个1即11；第三个就描述第二个，2个1即21；那么第四个就描述第三个，一个2一个1，即1211；………………

  利用的是递归的思想，先给出递归开始的条件，当n为1是，字符串为“1”；然后后面的递归的时候先表示出前一个字符串，然后对前一个字符串遍历，如果i和i+1相等，计数器count就加一，即几个几；如果不相等就把他们加到记录字符串的res里。

  ```c++
  class Solution {
  public:
      string countAndSay(int n) 
      {
          if(n==1)
              return "1";
          string now = countAndSay(n-1);
          int count = 1;
          string res="";
          for(int i=0;i<now.size()-1;i++)
          {
              if(now[i]==now[i+1])  //这儿当i=now.size()-1时，i+1即now.size()并不会溢出，因为字符串最后还有一个字符串结束标志'\0'是没有算在字符串的长度里的，但是是可以通过下标访问到的
              {
                  count++;
                  continue;
              }
              else
              {
                  res+=to_string(count)+now[i];
                  count=1;
              }
          }
          return res;
      }
  };
  ```

- ### 53.最大子序和

  - 暴力列举，但是时间复杂度巨高，还是别用了

    ```c++
    class Solution {
    public:
        int maxSubArray(vector<int>& nums) 
        {
            if(nums.empty())
                return NULL;
            int max=nums[0];
            int sum=0;
            for(int i=0;i<nums.size();i++)
            {
                sum=0;
                for(int j=i;j<nums.size();j++)
                {
                    sum+=nums[j];
                    if(sum>max)
                        max=sum;
                }
            }
            return max;
        }
          
    };
    ```

  - 使用动态规划，看题目满不满足最优子结构，满足，那么选取状态，建立状态方程。这里选取状态可以是dp[i]表示[0,i]内最大子序列，但是这样选的话不容易确定dp[i-1]和dp[i]的关系。

    这里我们用dp[i]表示以nums中以nums[i]结尾的序列的和的最大值，那么nums[i]就必须加进去。那么如果dp[i-1]小于0，那么dp[i]就是nums[i],反之即为dp[i-1]+nums[i]。可以整合为dp[i]=Max(dp[i-1]+nums[i],nums[i])

    ```c++
    class Solution {
    public:
        int maxSubArray(vector<int>& nums) 
        {
            if(nums.size()==0)
                return 0;
            vector <int> dp(nums.size()); //vector后面括号里一个数表示vector的size为那个数同时所有数初值为0。一定要注意这里，定义vector时，如果没有赋初值，就不能用数组赋值的方式例如a[0]=0这样的方式一个一个赋值，只能用push_back或者insert。只有赋初值之后才可以用下面的那种方式，一定注意。 
            dp[0]=nums[0];
            for(int i=1;i<nums.size();i++)
            {
                dp[i]=max(dp[i-1]+nums[i],nums[i]);
            }
            sort(dp.begin(),dp.end());
            return dp[dp.size()-1];
        }  
    };
    ```

  - 同样的思路可以去掉上面代码中的dp数组，降低空间复杂度

    ```c++
    class Solution {
    public:
        int maxSubArray(vector<int>& nums) 
        {
            if(nums.size()==0)
                return 0;
            int sum=0;     //用来保存dp[i]
            int res=INT_MIN;  //用来保存最大的dp[i]
            for(int i=0;i<nums.size();i++)
            {
                sum=max(nums[i],sum+nums[i]);
                res=max(sum,res);
            }
          return res;
        }  
    };
    ```

- ### 58.最后一个单词的长度

  先找到最后一格不是空格的字符，然后从这个字符开始往前找，如果有空格就停，如果没有就一直加。

  ```c++
  class Solution {
  public:
      int lengthOfLastWord(string s) 
      {
          if(s.size()==0)
              return 0;
          int count=0,index=0;
          for(int i=s.size()-1;i>=0;i--)
          {
              if(s[i]!=' ')
              {
                  index=i;
                  break;
              } 
          }  
          for(int i=index;i>=0;i--)
          {
              if(s[i]==' ')
                  break;
              count++;
          } 
          return count;
      }
  };
  ```

- ### 66.加一

  相当于是初始carry为1的加法

  注意一下进位就行，还有最后插入用函数insert(i,x)，表示把x插入到迭代器i指向的位置，同时后面的元素自动往后移动
  
  ```c++
  class Solution {
  public:
      vector<int> plusOne(vector<int>& digits) 
      {
          int carry=1;
          int temp=0;
          for(int i=digits.size()-1;i>=0;i--)
          {
              temp=digits[i]+carry;
              digits[i]=temp%10;
              carry=temp==10?1:0;
              temp=0;
          }
          if(carry==1)
          {
              digits.insert(digits.begin(),1);
              return digits;
          }
          else
              return digits;
      }      
  };
  ```

- ### 67.二进制求和

  设置个进位，每次循环前求出两位数字和进位的和，然后分情况讨论就行了

  - 0。证明两个数字都为0且进位也为0，那么直接加0，进位置零
  - 1。两个数字有一个为1，进位为0或者两个数字都是0且进位为1，结果加1，进位置1
  - 2。结果加0，进位置1
  - 3。结果加1，进位置1

  > 这里还有个知识点就是字符串和数字的直接运算，字符如果和数字直接运算结果是数字，字符会自动转换为ascii码值参与运算。
  >
  > eg: char b='a';
  >
  > ​      int a=b+1;
  >
  > 结果a=98，即a的ascii码值加1再转换成是十进制，a的ascii为0x61,加1为62，转换成十进制就是98
  >
  > 但如果是加引号的话就是两个字符的ascii值进行运算
  >
  > eg： char b='a';
  >
  > ​         int a=b+'1';
  >
  > 结果a=146，即两个字符的ascii值61和31相加得92，转换成十进制即146
  >
  > ---
  >
  > 但是对于string来说，加一个字符串等于把它和原来的链接起来
  >
  > eg：string b="a"
  >
  > ​       b=b+'a'
  >
  > 输出结果即为字符串"aa"

  ```c++
  class Solution {
  public:
      string addBinary(string a, string b) 
      {
          int carry=0;
          while(a.size()>b.size())
              b='0'+b;
          while(a.size()<b.size())
              a='0'+a;
          for(int i=a.size()-1;i>=0;i--)
          {
              if(a[i]-'0'+b[i]-'0'+carry==0)
              {
                  a[i]='0';
                  carry=0; 
              }
              else if(a[i]-'0'+b[i]-'0'+carry==1)
              {
                  a[i]='1';
                  carry=0; 
              }
              else if(a[i]-'0'+b[i]-'0'+carry==2)
              {
                  a[i]='0';
                  carry=1; 
              }
              else
              {
                  a[i]='1';
                  carry=1;
              }
          }
          if(carry==1)
              a='1'+a;
          return a;
      }
  };
  ```
  
- ### 69.x的平方根

  - 直接用库函数sqrt()

  - 使用二分查找

    ```c++
    class Solution {
    public:
        int mySqrt(int x) 
        {
            long i=1,j=x/2+1;   //x的平方根不会大于x/2+1,可以数学证明，这儿直接用这个可以减小查找长度
            while(i<=j)
            {
                long mid=(i+j)/2;  //考虑到mid*mid可能会溢出int，使用long型
                long res=mid*mid;
                if(res==x)
                    return mid;
                else if(res>x)
                    j=mid-1;
                else
                    i=mid+1;
            }
            return j;  //为什么return j而不是i。因为如果跳出了while循环还没有返回，就是没有找到恰好开根号的mid，最后一次while时i=j，即此时的i或j是最所求整数中最接近根号x的，下面的mid=（i+j)/2其实结果还是i或j，而题目要求下取整，因此下面当res>x时，要取i-1或j-1;res<x时就取i或j，根据原代码中二分查找的执行代码，只有return j在res>x和<x时都符合要求。
            
        }
    };
    ```

  - 使用牛顿迭代法。关键在于边界的判定。往往计算方程的时候都有个精度限制，误差小于这个精度就可以停止迭代了。

    - ```c++
      class Solution {
      public:
          int mySqrt(int x) 
          {
              if(x==0)
                  return 0;
              double a=1,b=2;
              while(a!=b)      //double可以精确计算，不会死循环，虽然最后结果不准，但是会是double范围里最准的.这儿取初始值a为1，b其实是作为一个暂存上一个a值得变量，它只要初始化一个不等于a的值即可。a每次迭代完之后与上一次的值比较，不相等就说明还没找到所求的解，继续迭代。
              {
                  b=a;
                  a=(a+x/a)/2;
              }
              return int(a);
          }
      };
      ```

    - ```c++
      class Solution {
      public:
          int mySqrt(int x) 
          {
              double a=x;
              while(fabs(a*a-x)>=1) //收敛半径小于1即可，注意a得是double的
                  a=(a+x/a)/2;
              return int(a);
          }
      };
      ```

- ### 70.爬楼梯

  - 如果n级楼梯的爬法有f(n)个，那么可以分两种情况：

    - 第一次爬1级，那么剩下n-1级楼梯有f(n-1)种爬法
    - 第一次爬2级，那么剩下n-2级楼梯有f(n-2)种爬法

    那么f(n)=f(n-1)+f(n-2)，这实际上就是一个斐波那契数列。但是直接构造一个递归函数使用递归会超出时间限制，巧妙地使用了循环的方式

    ```c++
    class Solution {
    public:
        int climbStairs(int n) 
        {
            if(n==1)
                return 1;
            int first=1;
            int second=2;
            for(int i=3;i<=n;i++)
            {
                int third=first+second;
                first=second;
                second=third;
            }
            return second;        
        }
    };
    ```

  - 动态规划，可以看到这个问题是具有最优子结构的，即全局最优解可以从子问题最优解来构建。**其实和上面的斐波那契数列思路一样，斐波那契即为状态方程**

    第i阶有两种方式得到

    - 上i-1阶后向上爬一阶
    - 上i-2阶后向上爬两阶

    即到达i阶就是到i-1和i-2的和

     *dp*[*i*]=*dp*[*i*−1]+*dp*[*i*−2] 

    ```c++
    class Solution {
    public:
        int climbStairs(int n) 
        {
            if(n==1)  //这个判断是必须得有的，不然如果n是1的话下面的a[1]就是越界访问
               return 1;  
            vector<int> a(n);//表示a的size为n且都初始化为0
            a[0]=1;
            a[1]=2;
            for(int i=2;i<n;i++)
            {
                a[i]=a[i-1]+a[i-2];
            }
            return a[n-1];
        }
    };
    ```
  
- ### 83.删除排序列表中的重复元素

  直接操作，如果相等就跳过相等的那个指向下一个；如果不相等就直接跳过

  ```c++
  /**
   * Definition for singly-linked list.
   * struct ListNode {
   *     int val;
   *     ListNode *next;
   *     ListNode(int x) : val(x), next(NULL) {}
   * };
   */
  class Solution {
  public:
      ListNode* deleteDuplicates(ListNode* head) 
      {   
          if(head==NULL)
              return head;
          ListNode* p=head;
          while(p->next!=NULL)
          {
              if(p->val==p->next->val)
              {
                  p->next=p->next->next;
              }
              else
                  p=p->next;
          }
          return head;
      }
  };
  ```

- ### 100.相同的树

  满足两个条件，拓扑结构相等同时对应位置的值还要相等，使用递归的方法

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
   * };
   */
  class Solution {
  public:
      bool isSameTree(TreeNode* p, TreeNode* q) 
      {
          if(p==NULL&&q==NULL)             //两个都为空，那必然相等
              return true;                    
          if(p!=NULL&&q!=NULL&&p->val==q->val)  //两个都不为空且值还相等，即拓扑相同且值相等，那么他们满足，开始递归遍历他们的左右子节点
              return isSameTree(p->left,q->left)&&isSameTree(p->right,q->right);
          else             //拓扑不相同或者拓扑相同值不同
              return false;
      }
  };
  ```

- ### 88.合并两个有序数组

  - 先把两个数组放到一起，然后再排序。使用了insert和erase函数

    insert有三种

    - insert(i,n):把n插入到迭代器i的位置，然后原来的i和i后面的元素后移n位
    - insert(i,start,end):把迭代器start和end范围内的插入到i位置
    - insert(i,n,x):在迭代器i的位置插入n个x

    > 但是一定要注意的是，事先定义的迭代器，在对容器元素进行增删操作（insert，push_back或者erase等之后，可能会失效。因此要么定义一个迭代器，insert或者erase之后再定义一下，要么就用初始的begin和end，这两个永远是可以用）

    ```c++
    class Solution {
    public:
        void merge(vector<int>& nums1, int m, vector<int>& nums2, int n)
        {
            nums1.insert(nums1.begin()+m,nums2.begin(),nums2.end());
            nums1.erase(nums1.begin()+m+n,nums1.end());//因为默认后面有n个0；要删掉
            sort(nums1.begin(),nums1.end());
        }
    };
    ```

- ### 101.  对称二叉树

  从根节点开始看，如果根节点为空，符合；如果根节点不空，那么将就看根节点的左右子树是否是镜像的，然后再递归左子树的右子树和右子树的左子树，左子树的左子树和右子树的右子树

  ```c++
  class Solution {
  public:
      bool isSymmetric(TreeNode* root) 
      {
          if(root==NULL)
              return true;
          else 
              return isMirror(root->left,root->right);   
      }
      bool isMirror(TreeNode *p,TreeNode *q)
      {
          if(p==NULL&&q==NULL)
              return true;
          if((p==NULL&&q!=NULL)||(p!=NULL&&q==NULL))
              return false;
          if(p->val==q->val)
              return isMirror(p->left,q->right)&& isMirror(p->right,q->left);
          return false;
      }
  };
  ```

- ### 104.二叉树的最大深度

  深度优先搜索DFS

  ```c++
  class Solution {
  public:
      int maxDepth(TreeNode* root) 
      {
          if(root==NULL)
              return 0;
          int l=maxDepth(root->left)+1;
          int r=maxDepth(root->right)+1;
          return l>r?l:r;   
      }
  };
  ```

- 
