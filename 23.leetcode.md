- ### 1.两数之和

  这里用到了vector，是容器的意思，相当于一个数组而且里面什么数据类型都能放。

  声明用vector<int> a

  往里面加元素用a.push_back()，随便加什么都行

  a.size()即为长度，即元素的个数

  访问的话和数组一样用a[]就行

  **普通数组的长度用sizeof(a)/sizeof(a[0])，这样表示**

  - 遍历穷举

    ```c++
    class Solution
    {
      public:
      vector<int> twosum(vector<int> num,int target)
      {
        vector<int> a;
        for(int i=0;i<num.size();i++)
        {
          for(int j=i+1;j<num.size();j++)
          {
            if(num[i]+num[j]==target)
            {
              a.push_back(i);
              a.push_back(j);
            }
          }
        }
        return a;
      }
  };
    ```
  
    时间复杂度为O(n^2)，时间复杂度过高，因此尝试改进

  - 使用哈希方式

    ```c++
    class Solution 
    {
        public:
        vector<int> twoSum(vector<int> nums, int target) 
        {
            unordered_map<int,int> m;
            vector<int> rec;
            for(int i=0;i<nums.size();i++)
                m[nums[i]]=i;   //把所有的元素都放到哈希表里，key即为数，value为数在nums中的顺序数，m即给定一个数即nums[i]就可以得到它的value即顺序数i
            for(int i = 0 ; i < nums.size() ; i ++)
            {
                int t = target - nums[i];
                if(m.count(t)&&m[t]!=i)   //count(t)作用是看map中键值t的个数，就是看键值t在map中存不存在，因为key是不能重复的，因此count函数的值要么是0，要么是1.同时题目中要求一个数不能用两次，因此这个t的顺序数不能和i一样
                {
                     rec.push_back(i);
                     rec.push_back(m[t]);
                     break;
                }
            }
            return rec;
         }
  };
    ```
  
    使用了unordered_map<int,int> m定义了一个名为m的关键字和值都为int的哈希表，哈希就是给定一个关键字key能够找到对应的value值。key不能重复，但是不同的key可能会有相同的value就是所谓的冲突。

- ### 2.两数相加

  定义一个变量来记录进位，同时记住最后加完之后还要再下进位是否为1，是的话再加个1.

  ```c++
  class Solution
  {
  public:
      ListNode* addTwoNumbers(ListNode* l1,ListNode* l2)
      {
          ListNode* p=l1;
          ListNode* q=l2;
          ListNode* l3=new ListNode(1);
          ListNode* w=l3;
          int carry=0;
          int sum=0;
          while(p!=NULL||q!=NULL)
          {
              if(p!=NULL)
              {
                  sum+=p->val;
                  p=p->next;
              }
              if(q!=NULL)
              {
                  sum+=q->val;
                  q=q->next;
              }
              w->next=new ListNode((sum+carry)%10);
              w=w->next;
              carry=((sum+carry)>=10)?1:0;
              sum=0;
          }
          if(carry==1)
          {
              w->next=new ListNode(1);
          }
          return l3->next;
      }
          
  };
  ```
  
- ### 7.整数反转

  > 将一个给定的32位有符号整数，将数字每位上的整数进行反转。

  用x%10取出x的最后一位，设为pop。翻转后的数字用ans存贮，ans默认为0，然后通过ans=ans*10+x%10来不断迭代。

  还有个要注意的就是溢出问题，int是4个字节即32位，有符号的话INT_MAX即2的32次方减一即2147483647，同样得出INT_MIN。不能溢出也就是不能比max大不能比min小。

  溢出即ans*10+pop>INT_MAX，有两种可能：

  - ans>INT_MAX/10
  - ans==INT_MAX/10且pop>7(这里的7即为MAX的个位数)
  
  同样可以得出小于min的溢出条件。（注意32为符号整数表示的范围用的是补码的范围）
  
  ```c++
  class Solution
    {
        public:
        int reverse(int x) 
        {
            int ans=0;
            while(x)
            {
                int pop=x%10;
                if(ans>INT_MAX/10||(ans==INT_MAX/10&&pop>7))
                    return 0;
                if(ans<INT_MIN/10||(ans==INT_MIN/10&&pop<-8))
                    return 0;
                ans=ans*10+pop;
                x/=10;
            }
            return ans;     
        }
    };
  ```
  
- ### 9.回文数

  负数和能够整除10（除了0）都不行

  - 第一种利用类似于上面翻转整数的方法，再判断一下溢出就性

    ```c++
    class Solution
    {
      public:
        bool isPalindrome(int x)
      {
            if(x<0)
              return false;
            int ans=0;
            int y=x;
            while(x)
            {
                int pop=x%10;
                if(ans>INT_MAX/10||(ans==INT_MAX/10&&pop>7))
                    return false;
                ans=ans*10+pop;
                x/=10;
            }
            if(y==ans)
                return true;
            return false;
        }
             
    };
    ```

  - 第二种换了种循环的判断方法，while(x > ans)。跳出循环后如果是偶数个数字，那么x==ans就表明是回文数；如果是奇数个数字，那么跳出循环后x==ans/10就表明是回文数。

    ```c++
    class Solution 
    {
        public:
        bool isPalindrome(int x) 
         {
           if(x < 0 || (x % 10 == 0 && x != 0)) 
                 return false;
           int revertedNumber = 0;
             while(x > revertedNumber) 
             {
                revertedNumber = revertedNumber*10+x%10;
                x /= 10;
             }
             if(x == revertedNumber || x == revertedNumber/10)
                 return true;
             return false;
          }   
    };
    ```

- ### 13.罗马数字转整数

  要注意一个，要把string类型赋值给字符数组时，例如：

  - string s="abc"

    **char * a=const_cast<char *>(s.c_str())**

  - strlen()函数用来求取给定字符串或字符数组的长度，参数可以是字符数组的名字或字符串的名字

  - **length()用的时候是s.length();前面跟字符串。**s.size()效果一样

  - **sizeof()返回一个变量或者类型的大小，以字节为单位**

  - 暴力例举

    ```c++
  class Solution {
    public:
      int romanToInt(string s) {
            char *a=const_cast<char*>(s.c_str());
            int sum=0;
            for(int i=0;i<strlen(a);i++)
            {
                if(a[i]=='I'&&a[i+1]!='V'&&a[i+1]!='X')
                    sum+=1;
                if(a[i]=='I'&&a[i+1]=='V')
                    sum+=4;
                if(a[i]=='I'&&a[i+1]=='X')
                    sum+=9;
                if(a[i]=='V'&&a[i-1]!='I')
                    sum+=5;
                if(a[i]=='X'&&a[i+1]!='L'&&a[i+1]!='C'&&a[i-1]!='I')
                    sum+=10;
                if(a[i]=='X'&&a[i+1]=='L')
                    sum+=40;
                if(a[i]=='X'&&a[i+1]=='C')
                    sum+=90;
                if(a[i]=='L'&&a[i-1]!='X')
                    sum+=50;
                if(a[i]=='C'&&a[i+1]!='D'&&a[i+1]!='M'&&a[i-1]!='X')
                    sum+=100;
                if(a[i]=='C'&&a[i+1]=='D')
                    sum+=400;
                if(a[i]=='C'&&a[i+1]=='M')
                    sum+=900;
                if(a[i]=='D'&&a[i-1]!='C')
                    sum+=500;
                if(a[i]=='M'&&a[i-1]!='C')
                    sum+=1000;
              }
          return sum;
         }
    };
    ```

  - 使用哈希方式，建立哈希表m对应每个字母与每个数字，依次遍历字符串的每个字符，当

    m[s[i]]>=m[s[i+1]]时直接加上s[i]，当m[s[i]]<m[s[i+1]]时，就生成组合，输出后一位减前一位的差，同时i自加1，即往后空一位。

    > 往map里插入数据可以用m.insert(part<int,int>(10,10))
    >
    > map内部实现了一个红黑树，是有序的；而unordered_map即哈希表，无序的
    
    ```c++
    class Solution
    {
        public:
        int romanToInt(string s)
        {
            int sum=0;
            unordered_map<char,int> m;(用map代替unordered_map也可以)
            m.insert(pair<char,int>('I',1));//还有其他的插入方式参考c++书287页
            m.insert(pair<char,int>('V',5));
            m.insert(pair<char,int>('X',10));
            m.insert(pair<char,int>('L',50));
            m.insert(pair<char,int>('C',100));
            m.insert(pair<char,int>('D',500));
            m.insert(pair<char,int>('M',1000));
            for(int i=0;i<s.length();i++)
            {
                if(m[s[i]]>=m[s[i+1]])
                    sum+=m[s[i]];
                else
                {
                    sum+=m[s[i+1]]-m[s[i]];
                    i++;
                }
            }
            return sum;
         }
    };
    ```

- ### 14.最长公共前缀

  以第一个字符串为标准，一个一个往后比较

  ```c++
  class Solution {
  public:
      string longestCommonPrefix(vector<string>& strs) 
      {
          if(strs.empty())
              return "";
          string s=strs[0];
          for(int i=1;i<strs.size();i++)
          {
              for(int j=0;j<s.size();j++)
              {
                  if(strs[i][j]==s[j])
                      continue;
                  else
                  {
                      s.erase(j);  //这里erase(i)，i是数字的话会删除从i开始后面所有的，如果i是迭代器的话只会删除i这个位置上的，即string:: iterator=it。！！！但是vector的话只能用迭代器erase删除指定位置或者指定区域
                      break;
                  }
              }
          }
          return s;        
      }
  };
  ```

- ### 寻找字符串中无重复字符的最长字串的长度

  使用滑动窗口的办法，在字符和位置之间建立一个hash映射，初始建立m[256]={0},有256个元素，初始值全为零，256是因为ascii有256个。

  ```c++
  class Solution {
  public:
      int lengthOfLongestSubstring(string s) {
          int m[256]={0};//字符有256个,
          int left=0;//查找的左边界
          int mlen=0;//结果
          for(int i=0;i<s.length();i++)
          {
              if(m[s[i]]==0||m[s[i]]<=left)       //m[s[i]]=0证明没出现过，所以直接加进去（因此下面要用m[s[i]]=i+1,如果等于i的话第一个字符永远没出现过可以一直加，那后面就算重复出现也会当成没出现过，所以加个1，那么加1之后就表示的s[i]的位置的后一位），或者m[s[i]]<=left，即s[i]出现过但是m[s[i]]<=left即s[i]不在当前的窗口里，因此把他放进来
              {
                  mlen=max(mlen,i-left+1);
              }
              else
                  left=m[s[i]];
              m[s[i]]=i+1;
          }
          return mlen;
      }
  };
  ```
  
- ### 20.有效的括号

  思路就是从最内层的括号开始，一对一对的删除，看最后能不能都删除完，但是我们无法实直接从最里面开始删，因为不知道最里面的位置在哪儿，所以利用栈，通过递归的方式，遇到右括号就放进去，然后碰到左括号就依次和栈顶的比较。

  利用的STL中的stack，遇到左括号就压栈，然后遇到右括号就和栈顶的左括号比较，如果一样就把栈顶的左括号删除，如果不一样那么字符串无效。

  特别注意的是数组的越界问题，当栈为空时，stack.top()这种访问方式时非法无效的，因此当要用右括号和栈顶的元素比较之前要先看栈是否为空，如果为空，直接false。

  ```c++
  class Solution {
  public:
      bool isValid(string s)
      {
          if(s.size()%2!=0)         //如果字符串长度为奇数个，那么字符串必然无效
              return false;
          map<char,char> m;
          m.insert(pair<char,char>('(',')'));     //通过哈希建立左右括号的一一对应关系
          m.insert(pair<char,char>('[',']'));
          m.insert(pair<char,char>('{','}'));
          stack<char> n;
          for(int i=0;i<s.size();i++)
          {
              if(s[i]=='('||s[i]=='{'||s[i]=='[')
                  n.push(s[i]);
              if(s[i]==')'||s[i]==']'||s[i]=='}')
              {
                  if(n.empty())         //这个判断时必须的，如果没有这个判断，当栈为空时，下面的n.top()就是越界非法访问
                      return false;
                  if(s[i]==m[n.top()])
                  {
                      n.pop();
                  }
                  else
                      return false;
              }
          }
          if(n.empty())
              return true;
          else
              return false;
      }
  };
  ```

- ### 21.合并两个有序链表

  因为给的链表就是有序的，因此每次比较两个链表的表头元素，把小的插入到新的链表中。直到其中一个链表为空，然后把不为空的链表直接链接到新链表后面就行

  ```c++
  /**
   * Definition for singly-linked list.
   * struct ListNode {
   *     int val;
   *     ListNode *next;
   *     ListNode(int x) : val(x), next(NULL) {}
   * };
   */
  class Solution {
  public:
      ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) 
      {
          ListNode* l3=new ListNode(0);
          ListNode* p=l3;
          while(l1!=NULL&&l2!=NULL)
          {
              if(l1->val<=l2->val)
              {
                  p->next=new ListNode(l1->val);
                  p=p->next;
                  l1=l1->next;
              }
              else
              {
                  p->next=new ListNode(l2->val);
                  p=p->next;
                  l2=l2->next;           
              }  
          }
          if(l1==NULL)
              p->next=l2;
          else
              p->next=l1;
          return l3->next;
      }
  };
  ```

- ### 26.删除排序数组的重复项

  利用两个指针，一个慢指针留在前面保存数字，快指针向后一个一个遍历。

  - 如果慢指针等于快指针，证明是一样的数，那么慢指针不变，快指针向后加一然后再和慢指针比较
  - 如果不等，说明遇到新的数了，那么慢指针后移一位同时把当前快指针的值拷贝过来，然后快指针后移，继续比较。

  ```c++
  class Solution {
  public:
      int removeDuplicates(vector<int>& nums) 
      {
          if(nums.size()==0)
              return 0;
          int i=0;
          for (int j=1;j<nums.size();j++)
          {
              if(nums[i]!=nums[j])
              {
                  i++;
                  nums[i]=nums[j];
              }
          }
          return i+1;
      }
  };
  ```

  还可以利用STL的unique函数配合erase函数

  ```c++
  class Solution {
  public:
      int removeDuplicates(vector<int>& nums) 
      {
          vector<int>::iterator it;
          it=unique(nums.begin(),nums.end()); //unique会自动把范围内的重复的元素缩编，变成唯一的，返回一个指向最后一个元素下一位的迭代器
          nums.erase(it,nums.end());
          return nums.size();
      }
  };
  ```

- ### 27.移除元素

  和上题类似，也是利用了双指针的思想。慢指针记录!=val的数，快指针在前面找!=val的数然后传回来

  - 当==val时，不处理，计入下次循环，j++
  - 当!=val时，这是我们要的值， 这时两个指针同时自加1，然后把新出现的j指的值给i，继续遍历

  ```c++
  class Solution {
  public:
      int removeElement(vector<int>& nums, int val) 
      {
          if(nums.size()==0)
              return 0;
          int i=0;
          for(int j=0;j<nums.size();j++)
          {
              if(nums[j]!=val)
              {
                  nums[i]=nums[j];
                  i++;
              }
          }
          return i;
      }
  };
  ```

- ### 28.实现strStr()即在一个大字符串中匹配另一个小的字符串同时输出小字符串在大字符串中出现的第一个位置的索引

  - 自己写的，暴力比较，遍历大字符串，然后每遍历一次就和小字符串比较一次。但是时间复杂度贼高

    ```c++
    class Solution {
    public:
        int strStr(string haystack, string needle) 
        {
            if(needle.size()==0)
                return 0;
            int n=needle.size();
            int count=0;
            for(int i=0;i<haystack.size();i++)
            {
                for(int j=0;j<needle.size();j++)
                {
                    if(needle[j]==haystack[i+j])
                        count+=1;
                    else
                        break;
                }
                if(count==n)
                    return i;
                else
                    count=0;
            }
            return -1;
        }
    };
    ```

  - 也是暴力比较但是改进过，比上面mine好

    ```c++
    class Solution {
    public:
        int strStr(string haystack, string needle) {
            if(needle.empty())
                return 0;
            
            int i=0,j=0;
            while(haystack[i]!='\0'&&needle[j]!='\0')  //直到其中一个遍历完了才停
            {
                if(haystack[i]==needle[j])
                {
                    i++;
                    j++;
                }
                else
                {
                    i=i-j+1;      //i和j是同步的，如果不一样，匹配失败，i要回退到到开始比较的位置的下一个位置
                    j=0;
                }
            }
            if(needle[j]=='\0')
                return i-j;   //needle最后匹配到0证明匹配完了，i-J就回到最初的起点
            
            return -1;
        }
    };
    
    ```

  - 直接用库函数中的find函数，a.find(b）直接就是结果

    ```c++
    if(needle.empty())
        return 0;
    int pos=haystack.find(needle);
    return a;
    ```

    时间复杂度和空间复杂度都很低，但是没啥技术含量

- ### 35.搜索插入位置

  - 自己写的用循环的方式，写的太冗余了

    ```c++
    class Solution {
    public:
        int searchInsert(vector<int>& nums, int target) 
        {
            if(target<=nums[0])
                return  0;
            for(int i=0;i<nums.size()-1;i++)
            {
                if(target==nums[i])
                    return i;
                if(target>nums[i]&&target<nums[i+1])     
                    return i+1;
            }
            if(target<=nums[nums.size()-1])
                return nums.size()-1;
            else
                return nums.size();
        }
    };
    ```

  - 乐乐大佬的，一样的思路当时代码实现很简洁

    ```c++
    class Solution {
    public:
        int searchInsert(vector<int>& nums, int target) 
        {
            int len=nums.size();
            if(nums.size()==0)
                return 0;
            for(int i=0;i<nums.size();i++)
            {
                if(target<=nums[i])
                    return i;
            }
            return len;
        }
    };
    ```

  - 折半查找。主要就是三个指针，head，mid和last，head=0，last=maxsize-1，然后mid初始设置为0，while（head<last)的时候循环，每次循环先设置mid=(last-head)/2+head.

    ```c++
    class Solution {
    public:
        int searchInsert(vector<int>& nums, int target) 
        {
            int head=0;
            int mid=0;
            int last=nums.size()-1;
            while(head<last)
            {
                mid=(last-head)/2+head;
                if(target>nums[mid])
                    head=mid+1;
                else if(target<nums[mid])
                    last=mid-1;
                else
                    return mid;            
            }
            if(target<=nums[head])
                return head;
            return head+1;
        }
    };
    ```

- ### 38.报数

  利用的是递归的思想，题目的意思是从第二个开始（包括第二个），数字对应的字符串是用来描述上一个字符串的数字的。

  第一个是1，那么第二个就描述第一个，1个1即11；第三个就描述第二个，2个1即21；那么第四个就描述第三个，一个2一个1，即1211；………………

  利用的是递归的思想，先给出递归开始的条件，当n为1是，字符串为“1”；然后后面的递归的时候先表示出前一个字符串，然后对前一个字符串遍历，如果i和i+1相等，计数器count就加一，如果不相等就把他们加到记录字符串的res里。

  ```c++
  class Solution {
  public:
      string countAndSay(int n) 
      {
          if(n==1)
              return "1";
          string now=countAndSay(n-1);
          int count=1;
          string res="";
          for(int i=0;i<now.size();i++)
          {
              if(now[i]==now[i+1])
              {
                  count++;
                  continue;
              }
              else
              {
                  res+=to_string(count)+now[i];
                  count=1;
              }
          }
          return res;
      }
  };
  ```

- ### 53.最大子序和

  - 暴力列举，但是时间复杂度巨高，还是别用了

    ```c++
    class Solution {
    public:
        int maxSubArray(vector<int>& nums) 
        {
            if(nums.empty())
                return NULL;
            int max=nums[0];
            int sum=0;
            for(int i=0;i<nums.size();i++)
            {
                sum=0;
                for(int j=i;j<nums.size();j++)
                {
                    sum+=nums[j];
                    if(sum>max)
                        max=sum;
                }
            }
            return max;
        }
          
    };
    ```

  - 使用动态规划，看题目满不满足最优子结构，满足，那么选取状态，建立状态方程。这里选取状态可以是dp[i]表示[0,i]内最大子序列，但是这样选的话不容易确定dp[i-1]和dp[i]的关系。

    这里我们用dp[i]表示以nums[i]结尾的序列的最大值，那么nums[i]就必须加进去。那么如果dp[i-1]小于0，那么dp[i]就是nums[i],反之即为dp[i-1]+nums[i]。可以整合为dp[i]=Max(dp[i-1]+nums[i],nums[i])

    ```c++
    class Solution {
    public:
        int maxSubArray(vector<int>& nums) 
        {
            if(nums.size()==0)
                return 0;
            vector <int> dp(nums.size()); //vector后面括号里一个数表示vector的size为那个数同时所有数初值为0。一定要注意这里，定义vector时，如果没有赋初值，就不能用数组赋值的方式例如a[0]=0这样的方式一个一个赋值，只能用push_back或者insert。只有赋初值之后才可以用下面的那种方式，一定注意。 
            dp[0]=nums[0];
            for(int i=1;i<nums.size();i++)
            {
                dp[i]=max(dp[i-1]+nums[i],nums[i]);
            }
            sort(dp.begin(),dp.end());
            return dp[dp.size()-1];
        }  
    };
    ```

  - 同样的思路可以去掉上面代码中的dp数组，降低空间复杂度

    ```c++
    class Solution {
    public:
        int maxSubArray(vector<int>& nums) 
        {
            if(nums.size()==0)
                return 0;
            int sum=0;     //用来保存dp[i]
            int res=INT_MIN;  //用来保存最大的dp[i]
            for(int i=0;i<nums.size();i++)
            {
                sum=max(nums[i],sum+nums[i]);
                res=max(sum,res);
            }
          return res;
        }  
    };
    ```

- ### 58.最后一个单词的长度

  一定要注意结尾是空格的情况，先把结尾的空格都删掉，然后再从结尾开始找第一个空格的位置，两者中间夹的就是最后一个单词。

  这里记住一个find_last_of()函数，例如s.find_last_of('a')就可以返回s种出现的第一个a的位置，和前面28题的find函数类似。

  ```c++
  int lengthOfLastWord(string s)
  {
      int end=s.size()-1;
      while(s[end]==' ')            //把s末尾的空格都删除完
      {
          s.erase(end);
          s--;
      }
      end=s.find_last_of(' ');          //末尾的空格都删除完之后知道最后一个空格出现的位置，它和末尾中间夹的就是最后一个单词，当然如果没有空格的话会返回-1，还是满足最后return的表达式。注意find——last——of只会匹配第一个字符，即不管你后面输入的是什么，只匹配第一个
      return s.size()-1-end;    
  }
  ```

- ### 66.加一

  注意一下进位就行，还有最后插入用函数insert(i,x)，表示把x插入到迭代器i指向的位置，同时后面的元素自动往后移动

  ```c++
  class Solution {
  public:
      vector<int> plusOne(vector<int>& digits) 
      {
          int size=digits.size();
          int carry=1;
          int temp=0;
          for(int i=size-1;i>=0;i--)
          {
              temp=digits[i]+carry;
              digits[i]=(digits[i]+carry)%10;
              carry=temp==10?1:0;
              temp=0;
          }
          if(carry==1)
          {
              digits.insert(digits.begin(),1);
              return digits;
          }
          else
              return digits;
              
      }
  };
  ```

- ### 67.二进制求和

  设置个进位，每次循环前求出两位数字和进位的和，然后分情况讨论就行了

  - 0。证明两个数字都为0且进位也为0，那么直接加0，进位置零
  - 1。两个数字有一个为1，进位为0或者两个数字都是0且进位为1，结果加1，进位置1
  - 2。结果加0，进位置1
  - 3。结果加1，进位置1

  > 这里还有个知识点就是字符串和数字的直接运算，字符如果和数字直接运算结果是数字，字符会自动转换为ascii码值参与运算。
  >
  > eg: char b='a';
  >
  > ​      int a=b+1;
  >
  > 结果a=98，即a的ascii码值加1再转换成是十进制，a的ascii为0x61,加1为62，转换成十进制就是98
  >
  > 但如果是加引号的花就是两个字符的ascii值直接相加
  >
  > eg： char b='a';
  >
  > ​         int a=b+'1';
  >
  > 结果a=146，即两个字符的ascii值61和31相加得92，转换成十进制即146
  >
  > ---
  >
  > 但是对于string来说，加一个字符串等于把它和原来的链接起来
  >
  > eg：string b="a"
  >
  > ​       b=b+'a'
  >
  > 输出结果即为字符串"aa"

  ```c++
  class Solution {
  public:
      string addBinary(string a, string b) 
      {
          int al=a.size(),bl=b.size();
          int carry=0;
          while(a.size()>b.size())
          {
              b='0'+b;
          }
           while(a.size()<b.size())
          {
              a='0'+a;
          }
          for(int i=a.size()-1;i>=0;i--)
          {   
              if(a[i]-'0'+b[i]-'0'+carry==0)
              {
                  a[i]='0';
                  carry=0;
              }
              else if(a[i]-'0'+b[i]-'0'+carry==1)
              {
                  a[i]='1';
                  carry=0;
              }
              else if(a[i]-'0'+b[i]-'0'+carry==2)
              {
                  a[i]='0';
                  carry=1;
              }
              else 
              {
                  a[i]='1';
                  carry=1;
              }
          }
          if(carry==1)
              a.insert(a.begin(),'1');
          return a;
      }      
  };
  ```

- ### 69.x的平方根

  - 直接用库函数sqrt()

  - 使用二分查找

    ```c++
    class Solution {
    public:
        int mySqrt(int x) 
        {
            long i=0,j=x/2+1;
            while(i<=j)
            {
                long mid=(i+j)/2;
                long res=mid*mid;
                if(res>x)
                    j=mid-1;
                else
                    i=mid+1;
            }
            return j;
            
        }
    };
    ```

  - 使用牛顿迭代法。关键在于边界的判定。往往计算方程的时候都有个精度限制，误差小于这个精度就可以停止迭代了。

    - ```c++
      class Solution {
      public:
          int mySqrt(int x) 
          {
              long res=x;
              while(res*res>x)     //牛顿迭代法一次比一次靠近最优值，因此下一次肯定比上一次好，一直比x大那么第一次小的时候的值就是求的
              {
                  res=(res+x/res)/2;
              }
              return res;
          }
      };
      ```

    - ```c++
      class Solution {
      public:
          int mySqrt(int x) 
          {
              if(x==0)
                  return 0;
              double a=1,b=2;
              while(a!=b)      //double可以精确计算，不会死循环，虽然最后结果不准，但是会是double范围里最准的
              {
                  b=a;
                  a=(a+x/a)/2;
              }
              return int(a);
          }
      };
      ```

    - ```c++
      class Solution {
      public:
          int mySqrt(int x) 
          {
              double a=x;
              while(fabs(a*a-x)>=1) //收敛半径小于1即可，注意a得是double的
                  a=(a+x/a)/2;
              return int(a);
          }
      };
      ```

- ### 70.爬楼梯

  - 如果n级楼梯的爬法有f(n)个，那么可以分两种情况：

    - 第一次爬1级，那么剩下n-1级楼梯有f(n-1)种爬法
    - 第一次爬2级，那么剩下n-2级楼梯有f(n-2)种爬法

    那么f(n)=f(n-1)+f(n-2)，这实际上就是一个斐波那契数列。但是直接构造一个递归函数使用递归会超出时间限制，巧妙地使用了循环的方式

    ```c++
    class Solution {
    public:
        int climbStairs(int n) 
        {
            if(n==1)
                return 1;
            int first=1;
            int second=2;
            for(int i=3;i<=n;i++)
            {
                int third=first+second;
                first=second;
                second=third;
            }
            return second;        
        }
    };
    ```

  - 动态规划，可以看到这个问题是具有最优子结构的，即全局最优解可以从子问题最优解来构建。**其实和上面的斐波那契数列思路一样，斐波那契即为状态方程**

    第i阶有两种方式得到

    - 上i-1阶后向上爬一阶
    - 上i-2阶后向上爬两阶

    即到达i阶就是到i-1和i-2的和

     *dp*[*i*]=*dp*[*i*−1]+*dp*[*i*−2] 

    ```c++
    class Solution {
    public:
        int climbStairs(int n) 
        {
            if(n==1)
                return 1;
            if(n==2)
                return 2;
            vector<int> a(n+1,0);
            a[1]=1;
            a[2]=2;
            for(int i=3;i<=n;i++)
            {
                a[i]=a[i-1]+a[i-2];
            }
            return a[n];
        }  
    };
    ```

- ### 83.删除排序列表中的重复元素

  直接操作，如果相等就跳过相等的那个指向下一个；如果不相等就直接跳过

  ```c++
  /**
   * Definition for singly-linked list.
   * struct ListNode {
   *     int val;
   *     ListNode *next;
   *     ListNode(int x) : val(x), next(NULL) {}
   * };
   */
  class Solution {
  public:
      ListNode* deleteDuplicates(ListNode* head) 
      {   
          if(head==NULL)
              return head;
          ListNode* p=head;
          while(p->next!=NULL&&p!=NULL)
          {
              if(p->val==p->next->val)
              {
                  p->next=p->next->next;
              }
              else
                  p=p->next;
          }
          return head;
      }
  };
  ```

- ### 100.相同的树

  满足两个条件，拓扑结构相等同时对应位置的值还要相等，使用递归的方法

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
   * };
   */
  class Solution {
  public:
      bool isSameTree(TreeNode* p, TreeNode* q) 
      {
          if(p==NULL&&q==NULL)             //两个都为空，那必然相等
              return true;                    
          if(p!=NULL&&q!=NULL&&p->val==q->val)  //两个都不为空且值还相等，即拓扑相同且值相等，那么他们满足，开始递归遍历他们的左右子节点
              return isSameTree(p->left,q->left)&&isSameTree(p->right,q->right);
          else             //拓扑不相同或者拓扑相同值不同
              return false;
      }
  };
  ```

- ### 88.合并两个有序数组

  - 先把两个数组放到一起，然后再排序。使用了insert和erase函数

    insert有三种

    - insert(i,n):把n插入到迭代器i的位置，然后原来的i和i后面的元素后移n位
    - insert(i,start,end):把迭代器start和end范围内的插入到i位置
    - insert(i,n,x):在迭代器i的位置插入n个x

    > 但是一定要注意的是，实现定义的迭代器，在对容器元素进行增删操作（insert，push_back或者erase等之后，可能会失效。因此要么定义一个迭代器，insert或者erase之后再定义一下，要么就用初始的begin和end，这两个永远是可以用）

    ```c++
    class Solution {
    public:
        void merge(vector<int>& nums1, int m, vector<int>& nums2, int n)
        {
            nums1.insert(nums1.begin()+m,nums2.begin(),nums2.end());
            nums1.erase(nums1.begin()+m+n,nums1.end());
            sort(nums1.begin(),nums1.end());
        }
    };
    ```

- 
