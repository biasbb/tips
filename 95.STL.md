- #### STL六大部件

  ![](image/59.jpg)

  - **分配器，allocator**：内存分配函数operator new()和malloc()。operator new()的函数实现里面会调用malloc，而使用操作符（操作符即运算符，如+，-等）new的时候会先调用operator new()分配内存，再调用构造函数，因此最终的内存分配都回到最底层的malloc上。

    **分配器allocator是个模板类**，有两个函数allocate，调用operator new；deallocate调用operater delete。会帮助容器进行内存管理而不用我们了解底层的细节。

    临时对象的用法，int a=**allocator<int>()**.allcoate(512) 。在类名的后面加空的圆括号表示生成一个**临时对象**。

    由于malloc申请会附带overhead记录大量状态信息，属于额外开销，当内存量大的时候overhead在整体占的比例不大，但是申请小内存时就会占用较大的比例，效率不高

    **当然我们可以直接使用分配器来分配内存，就类似于new和malloc，但是使用分配器申请的时候需要数量同时还的时候也需要声明数量**。

    >当调用malloc(size)时，实际分配的内存大小大于size字节，这是因为在分配的内存区域头部有类似于
    >struct control_block {
    >unsigned size;
    >int used;
    >};
    >这样的一个结构，如果malloc函数内部得到的内存区域的首地址为void *p,那么它返回给你的就是p + sizeof(control_block)，而调用free(p)的时候，该函数把p减去sizeof(control_block)，然后就可以根据
    >((control_blcok*)p)->size得到要释放的内存区域的大小。这也就是为什么free只能用来释放malloc分配的内存，如果用于释放其他的内存，会发生未知的错误。

  - **容器**：

    分为两类，序列容器和关联容器

    ![](image/60.jpg)

    - **list**，老千层饼了。即iterator也是一个类，并不是单纯的一个指针，里面重载了很多指针要用到的运算符，是一个类因此才能实现许多单纯指针无法实现的智能操作

      ```c++
      //list是一个模板类，然后它里面有用到 __list_iterator
      template<class T,class Alloc=alloc>  
      class list
      {
          typedef __list_iterator<T,T&,T*> iterator;//只是定义别名，并不是声明成员变量
          ...
      }
      // __list_iterator又是一个模板类（结构体和类差不多）
      template<class T,class Ref,class Ptr>
      struct __list_iterator
      {
          typedef T value_type;
          .......
      }
      ```

    - ##### deque

      并不是完全连续的，是分段连续的，通过一个连续的vector作为控制区，然后控制区的每个节点控制对应一段连续的内存。

      deque的对象有四个指针

      1. 控制中心map
      2. 控制中心map的size
      3. 只想开头的迭代器
      4. 只想结尾下一位的迭代器

      iterator中有四个指针

      1. node指向该块内存在控制中心中对应的索引的位置
      2. cur指向当前对应的节点
      3. first和last指向当前分配的块的起点和终点

      deque对外呈现出连续的假象，主要归功于它的iterator，当走完一个内存块之后，会自动根据控制区map上的索引自动跳到下一个i块，这样看起来就是连续的

      ![](image/71.jpg)

      deque的insert有一种很聪明的做法，对于vector而言insert的话找到索引然后把后面的全往后推，然后插入。而对于deque，由于是双端队列，两边都可以移动，所以它会判断insert的位置离开始和结尾哪边比较近，然后从近的那边移动元素腾一个位置，然后插入。这样就减小了移动元素的个数

      同时deque的map是在vector的中间开始向两边递增，如果vector超了扩充的的话，map复制过去还是在vector的中间。如果放在vector的开头的话，map向后孔虫可以，但是向前扩充第一次就不够就要扩充vector，这样的话使vector得不到有效的利用。

    - **stack和queue**都是通过deque来实现，对应功能的函数底层都是调用deque的函数然后根据stack和queue的特点做一些修改。本身不做事，都是考deque来做，即stack和queue里其实内含了一个deque

      ![](image/72.jpg)

    

  - **迭代器，下面用list举例，其他的都类似（其中有一个很重要的设计，迭代器萃取机，是迭代器和算法算法之间的桥梁）**

    迭代器要定义五个typedef，类似于它的属性，algotithm调用它的时候会提问它，问他的这五个属性。

    下面algorithm传入的参数I即为迭代器，那么下面I::iterator即为回答。指针是一种退化的迭代器，如果把它作为迭代器传入，那么它并没有五个typedef，无法回答，直接用在algorithm里直接用就会出错。那么如何区分呢。下面通过一种间接的方式。

    使用中间层traits。即原来是algorithm直接问iterator，现在是algorithm问iterator_traits，然后traits再问iterator，if iterator是class，那么就返回相应的值；if iterator是个指针，那么它本身没有那五个特性，自然无法回答，这时traits就会代替pointer回答，然后传回algorithm。

    **提问的过程**

    ![](image/67.jpg)

    **筛选的过程**

    ![](image/68.jpg)

    ![](image/69.jpg)

    通过偏特化来实现，如果传进来的是一个迭代器类型，就返回迭代器的value_type，如果传进来的指针，就直接返回指针指向的值

    ---

    ！！！！！但是如果传进来的不是iterator而是一个指针，那么我么通过萃取机来区分。**<u>注意对于vector，由于它是连续的，使用vector模板传入的类型参数的类型的指针构造迭代器就可以，而不用再构造复杂的类</u>**。

    刚开始gnu也是这样做的，但是后来为了统一，把vector<int>::iterator

    也变成和后面的list等的一样了，但是一级一级看回来本质的实现还是和原来的一样用的普通指针，却多了很多的继承和跳转，有点多此一举

    ![](image/70.jpg)

  - **分配器**

  - **算法**

  - **仿函数**

- #### 模板特化

  - **全特化**

    使用模板时碰到一些特殊的类型需要特殊处理，不能直接使用当前的模板函数，所以需要写一个特化的版本。即专门写一个模板函数供该类型用

    ```c++
    template<class T>
    bool isEqual(T &a,T &b)
    {
        return a==b;
    }
    ```

    但是要比较字符串就不能用这个模板了，因此i我们为字符串单独写一个模板

    ```c++
    template<>
    bool isEaual<char *>(char * &a,char * &b)
    {
        return strcmp(a,b)==0;//strcmp接受的参数只能时char*,不能时string，会从头开始依次比较两个字符的ascii值，如果比较到结尾二者都相等就返回0，a>b返回1，反之返回-1
    }
    ```

    - 使用特化模板时，前面必须有基础模板
    - 写的时候前面template然后后面<>里什么都不用写
    - 函数名后面要跟上特化类型，而且后面参数列表的样式要和原来的相同
    - 调用的时候直接用就行，可以不显式声明特化类型，会自动推导

  - **偏特化。偏特化只有类有因为有函数重载的概念，C++根据参数的类型来判断重载哪一个函数，如果还进行偏特化，这就与重载相冲突。**

    有两种情况

    - 部分特化，即只对类模板的一部分模板类型进行特化

      ```c++
      template<class T1,class T2>
      class Test{}
      //部分特化
      templeat<class T2>  //这儿只写未进行特化的模板类型，转换过的就不用写，因此全特化的时候因为都进行特化，所以就是空的都不用写。这儿我们特化T1，所以T1不写，只写T2就可以
      class T<int,T2>{}
      ```

    - 对模板类型的**范围的限制**

      ```c++
      template<class T1,class T2>
      class Test{}
      
      templeat<class T1,class T2>  //只写未进行特化的模板类型，我们这儿只是对它做了限制但是没有指定确定的类型，即没有特化写上
      class T<T1*,T2*>{}   //对类型作限制，当传入指针的时候用这个模板
      ```

- 

