1. **01和完全背包的区别就在于状态转移方程中完全是i而01是i-1**
2. **二维的时候N和W里层外层没有区别，但是如果是1维的话即近把W作为状态变量，那么N外W内 的话求得是组合数，而N内W外求的是排列数**
3. **一维得话初始化dp[0]为1即可；二维得话初始化`dp[i][0]`为1**

---

给一个可以装载重量为W的背包和N个物品，每个物品有重量和价值两个属性，现在用这个背包装东西 ，最多能装的价值是多少

```c++
例如W=4，有三个物品
wt={2,1,4}
val={4,2,3}
```

结果是6，选择前2件物品装，总重量为3，<4，活得了最大价值6

- 首先定义状态：

  ```c++
  dp[i][w]，对于前i件物品，当背包容量限制为w时，可以获得的最大价值。
  例如dp[3][4]=6,表示W不超过4的情况下，只从前3个物品中选择，获得的最大价值为6
  ```

- 状态转移

  ```c++
  对于dp[i][w]，可以根据是否装了第i件物品分为两种状态
  1.没有装。那么dp[i][w]=dp[i-1][w]
  2.装了第i件物品，那么dp[i][w]=dp[i-1][w-wt[i-1]]+val[i-1]
  ```

  用i-1是因为我们描述的i为第i个，是从1开始的，那么对应到数组中对应的索引就是i-1

- 代码实现

  N和W在内层外层循环结果都一样，因为最后得出的是依次组合问题。
  
  ```c++
  int knapsack(int W,int N,vector<int>& wt,vector<int>& val)
  {
      vector<vector<int>> dp(N+1,vector<int>(W+1)); //初始化为0，我们定义的i是第i个，所有最后要能选择到dp[N][W],即要有N+1 * W+1大的二维数组
      
      for(int i=1;i<=N;i++)   //从选择第一个物品开始遍历
      {
          for(int w=1;w<=W;w++)
          {
              if(w-wt[i-1]<0)  //即当前的背包容量装不下第i个物品，那么只能选择不装
                  dp[i][w]=dp[i-1][w];
              else
              {
                  dp[i][w]=max(dp[i-1][w],
                               dp[i-1][w-wt[i-1]]+val[i-1]);
              }
          }
      }
      return dp[N][W];
}
  ```
  
- 完全背包和01的区别就在于每个物品可以重复的选取

  01的状态转移方程为

  ```c++
  dp[i][w]=max(dp[i-1][w],dp[i-1][w-wt[i-1]]+val[i-1]);
  ```

  那么完全的状态转移方程就是

  ```c++
  dp[i][w]=max(dp[i-1][w],dp[i-1][w-K*wt[i-1]]+K*val[i-1]);
  ```

  https://blog.csdn.net/sunqi568/article/details/81320364

  经过推导，上面的方程等价于

  ```c++
  dp[i][w]=max(dp[i-1][w],dp[i][w-wt[i-1]]+val[i-1]);
  ```

  就差了一个后面的dp的x坐标，01的是i-1，完全的是i

  

  