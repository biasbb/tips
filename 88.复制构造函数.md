复制构造函数是构造函数的一种，只有一个形参且形参必须为该类类型的引用，可以是const也可以不是，但是为了整个程序的安全，还是加上const，防止对实参的意外修改。

#### **调用复制构函数的三种情况**

- ##### 函数的参数为类对象

  ```c++
  class A
  {
      private:
      int a;
      public:
      A(int b)
      {
          a=b;
      }
      A(const A& c)
      {
          a=c.a;
      }
      ~A(){}
  };
  void fun(A c)
  {
      cout<<"xixi";
  }
  int main()
  {
      A a;
      fun(a);
  }
  ```

  当调用fun()时，由于其对象时A类型，因此调用复制构造函数，会产生几个步骤：

  1. a传入fun的形参时，会产生一个临时变量，就叫c吧，也是A类型的对象
  2. 调用复制构造函数把a的值传给c。这两步有点像 A c(a)；
  3. 等fun执行完之后，析构掉c

- ##### 函数的返回值为类对象

  ```c++
  class A
  {
      private:
      int a;
      public:
      A(int b)
      {
          a=b;
      }
      A(const A&amp; c)
      {
          a=c.a;
      }
      ~A(){}
  };
  A fun()
  {
      A temp(0);
      return temp;
  } 
  int main()
  {
      fun();
  }
  ```
  
  当fun执行到return时，会产生下面几个步骤：
  
  1. 产生一个临时变量，就叫d吧
  2. 调用复制构造函数把temp的值给d。这两步相当于 A d(temp)
  3. 等函数执行到最后先析构temp局部变量
  4. 等fun执行完再析构d对象
  
- ##### 用一个对象初始化另一个对象

  注意是初始化，即另一个对象以前是不存在的，下面这两种形式等价

  ```c++
  A a(100);
  A b=a;
  A b(a);    //2和3这两种形式是等价的
  ```

  要和赋值运算符函数相区别

  复制构造函数是用存在的对象来初始化一个以前不存在的对象，而赋值运算符是两个对象都已经初始化好了，然后把其中一个对象赋值给另外一个。

##### 为什么形参必须为引用？

如果不是引用，由于参数是类对象，因此当有函数调用复制构造函数时，由于复制构造函数的参数也是类对象，那么继续调用复制构造函数，循环递归下去会使程序崩溃