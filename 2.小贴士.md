- ### DNS（Domain Name System，域名系统）

  域名，网址，URL

  - eg. www.baidu.com

    域名 baidu.com，域名就是IP地址的一个代称，是为了方便大家记忆  

    域名系统DNS就是用于将域名和IP地址相互转换

  - URL，俗称网址

     www.baidu.com

- ### RFC 

   Request For Comments（RFC），是一系列以编号排定的文件。文件收集了有关互联网相关信息，以及UNIX和互联网社区的软件文件。

- 如果人民害怕政府，这就是暴政；如果政府害怕人民，这就是自由。  ——托马斯·杰斐逊

- 我慢慢地、慢慢地了解到，所谓父女母子一场，只不过意味着，你和他的缘分就是今生今世不断地在目送他的背影渐行渐远。你站立在小路的这一端，看着他逐渐消失在小路转弯的地方，而且，他用背影默默告诉你：不必追

- 真值，原码，补码，反码，移码

  到目前为止，我们学习了十进制、二进制、八进制、十六进制等用来代表实际数值的数，称为真值。
  正数的原码，反码，补码都是一致的就是前面加了个0表示正数，就是符号位加上真值的绝对值。如+11，这就是真值，原码即为011，**原码就是把真值的符号用0和1表示了**
  负数的（1）原码要在前面加个1表示表示是负数。
  ​            （2）反码除符号位外全部取反。
  ​            （3）补码除符号位以外剩下的取反加一。

   移码:对正数而言就是把符号位取反就可以了，对负数而言就是所有的位（包括符号位）取反加一。

   0的表示形式   原码: [+0]原=0000000  [-0]原=1000000
  ​                         反码: [+0]反=0000000  [-0]反=11111111
  ​                         补码: [+0]补=0000000  [-0]补=0000000
  ​                         移码: [+0]移=1000000  [-0]移=1000000

- 人们往往不相信暴虐粗糙的口诛笔伐，而相信和颜悦色的别有用心。

- ### BT

  即bittorrent。比特流。是一种传输协议。有特定后缀的BT文件也有特定的下载方式，下载的人的越多，速度越快。

- ### 平假名和片假名

  平假名主要是用来表示日本固有的一些文字，说是平其实看着拐弯那种

  片假名是用来表示外来语等，看起来横平竖直不拐弯

- ### 给时光以生命，而不是给生命以时光

  To the time to life,rather than to the life in time

  时间是不会停止没有感情的，我们应该把握时间，把自己丰富多彩的人生系在时间线上，而不是用空洞毫无亮点的时间来填充我们的生命历程

- ### 固态硬盘那些事

  - 总线标准，是数据传输方式，也可以叫通道：PCI-E、SATA、并口（PATA）

    并口（PATA）对应的是IDE协议，为旧机械硬盘量身定做

    串口（SATA）对应的是AHCI协议，为新机械硬盘量身定做（为了缩短磁盘寻道时间）；

    扩展串口（PCIe） 对应的是NVMe协议，为厉害的固态硬盘量身定做

  - 物理接口：SATA、M.2，pci-e

     其实物理接口用什么和速度是没什么关系的，如果是SATA接口那么就是使用SATA通道走AHCI协议。而M.2接口有两种接口模式socket2和socket3，socket2对应的接口是bkey，对应的是传输模式为sata,如果用这个话那么用M.2物理接口和SATA是没有区别的。而socket3对应的接口是mkey，走的是PCI-e，这个时候才用的是更快的PCI-e。注意，走pcie不等同于支持nvme，pcie硬盘也有支持AHCI的

     **因为总线是pci-e标准，其实m.2接口的固态使用的时候是通过pci-e通道传数据，也有物理接口的pci-e，这种接口比m.2少了个转化的过程，理论上比m.2接口的速度快一些。**

  -   传输协议：AHCI、NVMe

      PCIE相比SATA有更快的速度，SATA总线一般采用AHCI协议，而PCIE一般使用NAMe协议。

      但需要注意的是使用NVMe的一定使用PCI-e，但是使用PCI-e的未必使用Nvme，也可能使用AHCI

      目前来看PCI-e搭配NVMe是最快的

  - **<u>*总结</u>***：ssd的快慢和物理接口用什么没哈关系，主要看通道的选择和传输协议的选择，使用PCI-e的比SATA的更快，而且使用PCI-e的里面使用NVMe的最快。

- ### 渲染render（给予，呈现，递交，表达）

  - 存在于CG领域，电脑绘图中以软件由模型生成图像的过程，通俗理解就是绘制，其实把render直接翻译为绘制更好，就是把场景画出来的意思。
  - 我们平常说的渲染视频是一个过程，把一个视频进行各种处理添加字幕音乐等等等，把这些内容整合到一个完整的符合某个视频格式的视频文件中的过程就叫做渲染，也可以叫整合输出吧。

- ### P问题，NP问题，NPC问题。

   - P问题：可以找到一个能在多项式的时间里解决它的算法的问题

   - NP问题：可以在多项式时间里验证一个解。即可以在多项式时间内猜看给定的这个解对不对。(显然P属于NP，多项式时间的解都出来了，那么验证一个解当然可以，但是NP是否等于P现在还没有解决，是一个信息学巅峰问题)

   - NPC问题（NP完全问题）：首先是NP问题，其次所有的NP问题都能约化（**A问题的解法是B问题的一种特例，则A可以归约出B，即问题B的解法可以解决A，但是A的不能解决所有的B，A是B的一种特例。但要注意复杂度是A<=B。一个问题约化为另一个问题，时间复杂度增加了，问题的应用范围也增大了。通过对某些问题的不断约化，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替复杂度虽然低，但只能用于很小的一类问题的算法。联想起约化的传递性，如果不断地约化上去，不断找到能“通吃”（即复杂度>=所有的NP问题）若干小NP问题的一个稍复杂的大NP问题，最后能找到一个时间复杂度最高，并且能“通吃”所有的 NP问题的这样一个超级NP问题，这样的问题就是NPC问题**）成它，当然不仅仅一个，是一类问题（他们之间复杂度取等号）。所有的NP问题都能在多项式时间内转化成NPC问题。

     证明一个问题是 NPC问题也很简单。先证明它至少是一个NP问题，再证明其中一个已知的NPC问题能约化到它。（注意找规约是找复杂度>=它的，如果不是NPC要找NPC的话就找>它的；如果是要从已知的NPC证它是NPC的话，就要取等号了，它和已知的NPC问题有相同的复杂度，都是最高的，那它也是NPC问题）现在已经有很多已证明是NPC问题的NP问题。

   - 现在要证明的P是否等于NP就是看P和NPC的关系，就是看NPC问题能否在多项式时间内求解。因为所有的NP问题都可以约化到NPC问题，一旦证明P=NPC，即NPC问题可以在多项式时间内求解，自然就证明了NP问题可以在多项式时间内求解。

     > 3SAT即布尔可满足性问题，也是第一个被证明的NP完全问题。
   
- ### brew

   类似于ubuntu上apt-get，可以实现包管理而不用关心各种依赖和文件路径的情况，简单的一些操作

   - 安装包  brew install <packagename>
   - 卸载包  brew uninstall <packagename>
   - 查询可用包 brew search <packagename>
   - 查询已安装列表 brew list
   - 查询任意包的信息 brew info <packagename>
   - 更新homebrew  brew update
   
- ### 32位和64位

   **即操作系统的位数，也叫字长，是计算机内寻址总线的位数，即一次处理的数据位数。**它决定了虚拟地址的地址空间的最大大小，字长为32位即虚拟地址的范围为0~2^32-1，即最大4GB，而虚拟存储器是对程序存储器也就是主存(也叫内存)的一种抽象，因此32位最多支持4GB物理内存。同样63位就支持2^32GB的内存。但实际使用时不会把所以的物理存储全给内存，IO设备也要用到一部分，因此实际用回比理论的少。
   
- ### RGB

   RGB色彩模式是工业界的一种颜色标准，通过对红(R)，绿(G)，蓝(B)三个颜色通道的变化以及他们的相互之间的叠加得到各种各样的颜色。

   通常情况下，RGB各有256级亮度，从0到255，因此三种颜色可以组合出256✖️256✖️256=16777216种颜色。通常被简称为1600万色或千万色，也成24位色(2的24次方)。

- ### *和&运算

   **通俗说*是取指针所指地址的对应的值，而&是取变量对应的地址。**

   **（*p）操作是这样一种运算，返回p 的值作为地址的那个空间的取值。即返回p地址所指的值。**

   **（&p）则是这样一种运算，返回当时声明p 时开辟的地址。即取p的地址**

   int a=1                    (1)

   int *p=&a               (2)

   int c=*p                  (3)

   int **p1=&p;         (4)

   int d=**p1             (5)

   - 其中p为整型指针，它的值必须为地址，因此不能直接赋予a的值，而应该赋予一个地址，所以就用&a来取a的地址赋值给p。
   - 2式表明p为整型指针，指向a，那么int c=*p就是取指针p所指地址对应的的值
   - 4式表明p1为一个二级指针，指向p，那么5式中的**p1就是取p1所指的地址对应的指针所指的地址对应的值。

- ### 逻辑运算符与位运算符

   - 逻辑运算符即只判断逻辑真确还是错误，即&&，||和！。逻辑运算认为所有非零的参数都表示true，而参数零表示false。它最后表示的结果要么是true要么是false，分别返回1或者0

     0x11&&0x22   两个都不是0x00，因此结果是1，true

     0x11&&0x00  有一个是0x00，因此结果是0，false

   - 位运算符就是要一位一位的运算，即&，|和~。最后得到一个计算得出的结果。

- ### void的用法

   ###### main函数需要返回值，以前还可以用void main 现在不能用了，最好用int main然后结果加个return 0.或者写成int main(void)也是可以的。

- ### 不同的输出形式代表的意义

   int c1='a';

   cout<<c1<<endl;     97

   cout<<'c1'<<endl;     25393.  0x63 0x32,然后0x6332转换成十进制数就是25393

   cout<<"c1"<<endl;   c1    双引号里面是啥就输出啥

   cout<<int(c1)<<endl;   97  将字符型强制转换成整形，输出c1赋值字符的ascii值对应的十进制数。

   **<u>以上只是在c1=‘a’这种情况下的输出并不具有普适性，如果变成c='a'的话结果有不一样了</u>**

   int c='a';

   cout<<c;          97     

   cout<<'c';        c      这个和上边的就有区别了，如果里面刚好是一个字符或数字即存在于ascii表里面的单个的，那就直接输出这个数字或字符。但是如果不止一个，那就麻烦了，要把这些字符或者数字转换成ascii值然后按顺序组成一个十六进制数然后输出对应的十进制数。

   cout<<"c";       c      和上面一样

   cout<<int(c);   97    

   cout<<int('c');  99      这种强制类型转换的，如果没有单引号的话转的就是变量赋于的初值的ascii值变量是多少就转多少。如果有了单引号之后就和原来的变量是多少没多大联系了，直接把变量的名当成字符或者字符串来转。

   > 总结一下，
   >
   > - 如果没有引号那么原来是啥就输出啥；
   > - 如果加了单引号就要看里面是不是单个的字母或数字，是的话直接输出该字母或数字，如果不是的话即里面有不止一个字母或者数字或者二者混合，那就把他们按顺序一个一个转成ascii值再按顺序组合成一个hex数，最后输出这个数对应的十进制数。
   > - 如果加双引号的话里面是啥就输出啥。
   > - 如果是强制类型转换，没有单引号的话转的就是变量被赋于的初值的ascii值；有单引号的话，不管里面是一个还是多个都是转ascii值再转十进制（这里就是对于单个字符或者数字的时候和2的处理方式不一样，在这里单个多个都是按照同样的方式处理）
   >
   > **<u>总之一但有单引号那就和变量的初值没啥关系了就看这个字符或者字符串本身！！！！！！</u>**

- ### C++中三目运算符的意义

   三目运算符 <表达式1>?<表达式2>:<表达式3>

   先判断表达式1的逻辑值，如果逻辑值为真则整个式子的运算结果为表达式2的值；如果为假，则整个表达式的运算结果为表达式3的值。

- ### 单精度和双精度浮点数的十进制有效位数及误差出现的条件

   V=(-1)^s ✖️M✖️2^E

   s符号，M尾数，**<u>E阶码(是用阶数的移码减一表示的，在数值上就等于阶数+偏置值，偏置值就是2的n次方减一，n为阶码的位数</u>**)

   float

   float的规格化表示为：±1.f×2^E，其中，f是尾数，E是阶码，

   符号1位

   尾数23位

   阶码8位 

   比如十进制数123.125，其二进制表示为：1111011.001，规格化表示为1.111011001×2^6，阶数是6，即00000110，它的移码即为10000110，减1即为10000101；数值上即为133，就等于是阶数6加上偏置值128.

   ---

   double

   符号1位

   尾数52位

   阶码11位

   ---

   > <u>**规格化之后整数部分默认是1，可以省略，所以对于float而言，可以用23位存储24位的尾数。那么要把int用float表示时，只要int值（二进制表示）序列里只要存在这样的序列：从最低位开始找到第一个1，然后从这个1向高位数移动24位停下，如果更高的位上不再有1，那么该int值即可被float精确表示，否则就不行。简单说，就是第一个1开始到最后一个1为止的总位数超过24，那么该int值就不能被float类型精确表示。</u>**

   因此很容易得出，从1开始的连续整数里面第一个不能被float精确表示的整数，其二进制形式为：1000000000000000000000001，即16777217：1.000000000000000000000001×2^24，f
   有24位，最后一个1只能舍弃，也就是 1.00000000000000000000000×2^24，即1.0×2^24

   ，这个数实际上是16777216。也就是说16777217和16777216的内存表示是一样的。那么16777217之后下一个可以被float精确表示的是哪一个呢，就不断加1，直到满足第一个1和最后一个1不超过24位，即

   1000000000000000000000010，即16777218，如此下去。

   ```
   可以说7位的十进制可以完全精确，但是8位的不一定能精确
   ```

   双精度就是位数变了其他都一样的。

- ### 主析取范式和主合取范式

   主析取范式是极小项的析取（和），主合取范式是极大项的合取（积），主析取范式和主合取范式都是唯一的，那么相应的极小项和极大项也要为一，而极小项是且的形式，要表达结果唯一只能每个极小项都取真值为1，同样极大项要唯一只能取假。

   在用真值表法求主析取范式和主合取范式时，每个命题变元按照01变化展开，然后求出对应的整个命题表达式的真假值

   求主析取范式就取表达式的值为1时对应的P，Q，R的下标

   求主合取范式就取表达式的值为0

- ### 线性组合及线性相关

   > 一组向量A可以被另一组向量B线性表示，我A是B的一个线性组合，也可以说A可以被B线性表示。
   >
   > 在[向量空间](https://baike.baidu.com/item/%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4)V的一组向量**A:** 如果存在**不全为零**的数 k1, k2, ···,km ,和向量组的每个向量相乘加起来结果是0向量，则称向量组**A**是线性相关的。如果不存在这样的一组不全为0的数，即当且仅当 k1, k2, ···,km全为0时，相乘相加才是0向量，那么我们就称A是线性无关的。

- ### 激活函数

   激活函数就是在人工神经网络上运行的函数，引入它的目的是为了增加网络模型的非线性，就是增加拟合性。

   > 如果不用激励函数，每一层输出都是上层输入的线性函数，无论神经网络有多少层，输出都是输入的线性组合，这种情况就是最原始的[感知机](https://baike.baidu.com/item/%E6%84%9F%E7%9F%A5%E6%9C%BA/12723581)（Perceptron）。
   >
   > 如果使用的话，激活函数给神经元引入了非线性因素，使得神经网络可以任意逼近任何非线性函数，这样神经网络就可以应用到众多的非线性模型中。

   [详情请点击这篇博客](https://blog.csdn.net/v_july_v/article/details/51812459)

- ### 卷积神经网络

   - 卷积层

     > 对图像（不同的数据窗口数据）和滤波矩阵（一组固定的权重：因为每个神经元的多个权重固定，所以又可以看做一个恒定的滤波器filter）做**内积**，也叫点积（逐个元素相乘再求和）的操作就是所谓的『卷积』操作，也是卷积神经网络的名字来源

     中间滤波器filter与数据窗口做内积，其具体计算过程则是：4✖️0 + 0✖️*0 + 0*✖️0 + 0✖️*0 + 0*✖️1 + 0✖️*1 + 0✖️*0 + 0✖️*1 + -4*✖️2 = -8。

   - 池化层

     池化，简言之，即取区域平均或最大。

- ### 机器学习

   机器学习中分为有监督、半监督和无监督学习，主要就是看给的数据中有无数据标注，也就是答案，即给个x有对应的y与之对应，事先已经完成分类或说明即完成标注。无监督学习给的数据都是未标注的，要自己找数据间的内在关系。还有就是增强学习，这个与前三类区别较大，**他是没有标注数据集的**。

   > 根据周围环境的情况（预先给出大规则），采取行动，根据采取行动的结果，学习行动方式 ，仅根据环境情况自我学习。
   >
   > 我们机器学习的算法叫做Agent .要根据周围的环境来采取行动，在我们采取了行动之后，我们的算法相应就会收到反馈，这种反馈有的时候是reward奖赏机制反馈，有的时候是惩罚机制进行反馈，不管怎样当我们Agent算法得到反馈之后，就会相应改进自己的行为模式，之后再面对环境的其他情况下根据改进的算法再做出相应的action动作，环境再反馈给我们的Agent以此类推 我们的Agent实在一轮一轮的行动反馈中组件增强自己的智能 

- ### Agent

   > 通常，我们可以把Agent理解为“个人软件代理”，Agent是一种在分布式系统或者协作系统中，能够持续自主地发挥作用的计算实体，是一个个体，简称为“智能体”。广义上，Agent指具有智能的任何实体，可以是计算机硬件和智能软件（只要你想的到它都行，嘿嘿）。

- ### 深度学习过拟合

   如果一味的为了**提高对训练数据的预测能力**，所选的模型就要不断增加复杂性，不断增加参数，最终就会导致拟合的函数完美的预测训练集，但对新数据的测试集预测结果差。 过度的拟合了训练数据，而没有考虑到泛化能力。

   通俗讲就是模型太好了，给的都能学到，由于数据集的抽样本质，那么其中不可避免就会存在有误差的数据。比如样本是X，X=x（真值）+u（随机误差），给的是X他就按照X学，但我们实际的目的是要拟合x，一直学X就会让模型泛化能力变差，即普适性降低。

- ### 域名

   是与ip地址一一映射的，为了让人们可以更方便的访问互联网可不用去记住冗余的ip地址数串。

   baidu.com.  这就是一个域名也称为一级域名或者叫顶级域名。前面加个www之后也是域名，叫做二级域名，是为了便于访问和人们的习惯。二级域名是附属于一级域名的，它的存在不影响顶级域名，它没了顶级域名依然在，但是顶级域名如果没了下属的所有二三级等域名就全都没了。

- ### cd命令

   cd+空格+文件名就可以进到当前目录下指定的文件夹里面

   cd+空格+绝对路径（即/……...）可以从绝对路径进到指定的文件夹里,即从**根文件夹**开始访问（对于本机的话就是从系统盘Macintosh HD这个总目录开始往下找，找到对应路径的文件夹就打开)

   cd然后直接回车是返回用户主目录，cd ..是返回上一级目录。

- ### 使用命令行编写并运行C++程序

   shell里直接用vim xxx.cpp新建c++文件，然后摁i进入编辑模式，写完之后摁esc退出编辑模式，输入：wq然后会车。

   之后用g++ -o xxx 文件名.cpp用来编译文件名.cpp里的代码并生成文件名为xxx的可执行文件，如果直接用g++ 文件名.cpp的话默认是生成名为a.out的可执行文件。

   然后直接用./xxx或者用./a.out即可直接运行文件输出结果。

   ### 还有一些小的技巧

   ~（潮水符号）：这是房子（home）文件夹的快捷表示。例如本机的房子文件夹是bias，那么在具体操作时就可以用～来代替/bias。例如/bias/pictures就可以用～/pictures，二者等价。

   .*<u>(点)：这代表你现在所处的文件夹位置。在上面的例子上，我们在相对路径下操作Document文件夹，我们也可以通过./Document来进行处理[在前面运行最后编译生成对文件时就用到了这个，./a.out来运行文件，其他的用途尚未得知]</u>*

- ### 集合预算的两个重要定律

   集合的分配对偶率：A∩(B∪C)=(A∩B)∪(A∩C)；A∪(B∩C)=(A∪B)∩(A∪C) 

   > 需要注意的是括号是在后面的，这样才可以分配，如果括号里的是前面连个就不能用分配对偶率了。

   集合的对偶率：(A∪B)^C=A^C∩B^C；(A∩B)^C=A^C∪B^C

   > 这里后面^C的意思是取余集，其实就是德摩根率，真是闲的蛋疼。

- ### 狄杰斯特拉算法求一个顶点到其余各定点的最短路径

   [参加csdn的一篇博客](https://blog.csdn.net/jerry81333/article/details/54772709)

- ### 奇偶校验

   就是在传输的数据中加上了一位校验位。选择奇校验还是偶校验是事先确定好的。

   奇校验：原始数位+校验位总共有奇数个1（就是说如果原数位有奇数个1，那么校验位就是0；同样如果数据位有偶数个1那么校验位就是1.就是无论如何确保所有位一共有奇数个1，即全部异或起来之后是1。）

   偶校验：原始数位+校验位总共有偶数个1（原理和上面的奇校验相反）

   那么检测的时候就把接收到的所有数据位全部异或，奇校验的话结果是1就代表正确，偶校验的话结果是0就代表正确。**但是这种方法只能检测出奇数个错误，由异或的原理我们可以知道偶数个错误的结果和正确情况的结果是一致的；其次它只能检测出错误但是并不能修改。**

- ### 使用终端编写java

   与c++类似，vim 文件名.java新建一个java文件，i编辑然后esc退出编辑，：wq保存之后javac 文件名.java即可编译文件，生成一个.class后缀的文件，然后java 文件名即可执行出结果（文件名必须是类名，还有就是最后执行的时候输入文件名即可不用输入.class后缀）。

- ### 网关

   本质上就是个IP，因此在第三层实现不同网段之间的通信。网关的功能可以由不同的物理设备来实现，例如路由器或者三层交换机等。网关相当于一个网段的大哥，这个网段中的A要给其他网段的人B发东西需要先发给大哥，然后大哥发给目的网段的大哥，目的网段的大哥再给目的人B。

- ### 路由器和交换机

   **交换机一般会用到VLAN技术，即将物理的局域网LAN分割为不同的VLAN，根据MAC（二层交换机）或者IP（三层交换机，就和子网一样了）**

   **划分子网就是就要用到IP了，处于第三层，需要用到路由器或者三层交换机。**

   **路由器等于网络代理+交换机，交换机的功能路由器有，但是组建局域网的时候只需要交换机的连接功能而不需要网络代理功能，而且交换机的口一般很多，所以组建局域网一般用交换机<u>`（理论上只用交换机也可以组建局域网，如果不同网段不需要通信的话。但是不同网段要通信就需要用到网络模型中第三层的部分，例如路由器或者三层交换机）`</u>，当然路由器也可以但是用路由器的话它的网络代理功能就浪费了，而且路由器的口少，同样的设备用路由器需要更多个，就带来了更高的成本。**

   - 路由器工作在网络层，交换机工作在数据链路层

   - 路由器根据ip地址来转发ip数据报/分组，交换机是根据mac地址转发数据帧

   - 交换机主要是配合路由器用来组建局域网，只是做转发，ip划分是上层的路由器在做，交换机不分ip；而路由器主要是用来连接外网。通过交换机组建的局域网是不能访问外网的，所有主机用的都是私网的ip，必须通过路由器转换成公网的ip之后才能访问外网。

   - 简单来说交换机共享一根网线但是ip不同，而路由器共享一个ip

     > 交换机主要是用来构建局域网的，只转发数据，没有上网的功能，要上网的话交换机上面必然还有一个路由器。
     >
     > IP地址分为共有地址和私有地址。共有地址就是从ISP那儿申请的，私有地址就是局域网络里可以随便用的，不同的共有地址里的私有地址可以一样因为他们属于不同的局域网，而局域网与外网通信的话过的都是共有地址那个大IP。
     >
     > **校园网就是一个大的局域网，有一个或多个总的大ip即公网ip连接到internet，内部的局域网ip访问外部都是通过这一个或几个大ip，但是从外网看他们是一个ip，公网ip是独一无二的，但是内网ip可以重复，例如连接到一个路由器上的设备的内网ip是一样的。**

- ### 路由器当交换机使用

   - 关闭dhcp服务器（因为当交换机用的话就是前面的路由器来dhcp了，这儿再开就冲突了）

   - 在网络参数的lan口设置里把IP地址修改为与主路由器的LAN口IP在同一网段但不冲突。

     ![](image/2.jpg)

     在学校的话主路由器就是前面的大路由器，插网线使用ipconfig命令得到ip，跟他在一个网段然后不重复就行。

     再比如是网线先接主路由器，从lan口拉了一条出来又想接从路由器，而tplink路由器的默认IP地址为192.168.1.1，那么这儿我们就把后面的从路由器修改为192.168.1.X（X位于2-254之间）。**保存并重启路由器**。

   - 网线接lan口，然后设备也接lan口上网即可，无线也是可以用的

- ### 以太网

   它并不是网，而是一种局域网技术，包括一些局域网标准和一些通讯协议。

- ### IP

   用于局域网中的ip都是私有ip，是可以重复的，与共有ip不冲突，对内用内网ip来区分，对外上因特网的话是用一个公网的ip。

   - 私有IP地址范围：

     **A: 10.0.0.0~10.255.255.255 即10.0.0.0/8**

     **B:172.16.0.0~172.31.255.255即172.16.0.0/12**

     **C:192.168.0.0~192.168.255.255 即192.168.0.0/16**

   - 公有IP地址范围：

     **A: 0.0.0.1-- 9.255.255.255 & 11.0.0.0--126.255.255.255/8**

     **B:128.0.0.0--172.15.255.255 & 172.32.0.0--191.255.255.255/12**

     **C: 192.0.0.0-- 192.167.255.255 &192.169.0.0--223.169.255.255/16**

     > 私有的ip是非注册地址，是不允许出现在公网中的。

- ### 条形码与二维码

   - 条形码又一维码，仅在水平方向记录表达信息，其高度是为了扫描器的对准
   - 二维码相对于一维码增加了垂直方向，可以表达的信息大大增加因此更广泛的使用

- ### 物联网定义

   **物联网**(The Internet of Things)的概念是在1999年提出的，它的定义很简单：把所有物品通过射频识别等信息传感设备与互联网连接起来，实现智能化识别和管理。

- ### RFID

   射频识别技术，又称无线射频识别。是物联网中常用的一种技术，是一种[通信技术](https://baike.baidu.com/item/%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF/2865397)，可通过无线电讯号识别特定目标并读写相关数据，而无需识别系统与特定目标之间建立机械或光学接触。包括三部分

   - [应答器](https://baike.baidu.com/item/%E5%BA%94%E7%AD%94%E5%99%A8)：由天线，耦合元件及芯片组成，一般来说都是用[标签](https://baike.baidu.com/item/%E6%A0%87%E7%AD%BE)作为应答器，每个标签具有唯一的电子编码，附着在物体上标识目标对象。
   - 阅读器：由天线，[耦合](https://baike.baidu.com/item/%E8%80%A6%E5%90%88)元件，芯片组成，读取（有时还可以写入）标签信息的设备，可设计为手持式rfid读写器或固定式读写器。
   - 应用软件系统 ：是应用层软件，主要是把收集的数据进一步处理，并为人们所使用。

   像我们日常使用的身份证银行卡等都用到这个技术，这个技术可以有效的的吧物品于互联网连接起来，再通过一些软件我们可以很方便的对物品进行识别和管理。

- ### 数据和信息

   data并不等于information

   数据是事实或观察的结果，是对客观事物的逻辑归纳，适用于表示客观事物的未经加工的原始材料。

   而数据根据我们的要求进行加工处理之后提炼出来的我们想要的东西就是信息。

- ### 系统

   就是根据一个输出然后经过中间处理然后得出一个输出，这就是系统。

   我们做软件，做的就是中间处理那个步骤。

- ### 聚类和分类的关系

   - 对于分类来说，在对数据集分类时，我们是知道这个数据集是有多少种类的，比如对一个学校的在校大学生进行性别分类，我们会下意识很清楚知道分为“男”,“女”

   - 而对于聚类来说，在对数据集操作时，我们是不知道该数据集包含多少类，我们要做的，是将数据集中相似的数据归纳在一起。比如预测某一学校的在校大学生的好朋友团体，我们不知道大学生和谁玩的好玩的不好，我们通过他们的相似度进行聚类，聚成n个团体，这就是聚类。

     按照李春葆老师的话说，聚类是将数据对象的集合分成相似的对象类的过程。使得同一个簇（或类）中的对象之间具有较高的相似性，而不同簇中的对象具有较高的相异性

     ```
     分类是提前确定有多少个种类，然后分类标准是什么，然后开始分。
     而聚类提前什么都不知道，然后将相似性高的数据聚在一起。
     ```

- ### 并行与并发

   ​     什么是并发?（交替执行）

> 并发:指应用能够交替执行不同的任务,例:吃完饭->喝水 喝完水->睡觉 一觉醒来继续吃饭     

​             什么是并行?（同时执行）

> 并行:指应用能够同时执行不同的任务,例:吃饭的时候可以边吃饭边打电话,这两件事情可以同时执行

- ```
  两者区别:并发是交替执行,并行是同时执行.例如一个CPU处理两个任务，同一时间只能处理一个，那么A用10分钟然后B再用10分钟然后再循环，这个就是并发执行。那么我有了2个CPU，同时处理A和B，这就叫并行。
  ```

- ### 进程process和线程thread

  进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.
  线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.

  简而言之,一个程序至少有一个进程,一个进程至少有一个线程.

  > 开个QQ，开了一个进程；开了迅雷，开了一个进程。在QQ的这个进程里，传输文字开一个线程、传输语音开了一个线程、弹出对话框又开了一个线程。所以运行某个软件，相当于开了一个进程。在这个软件运行的过程里（在这个进程里），多个工作支撑的完成QQ的运行，那么这“多个工作”分别有一个线程。所以一个进程管着多个线程。通俗的讲：“进程是爹妈，管着众多的线程儿子”.

- ### whereis和which

  which这条命令主要是用来查找系统PATH目录下的可执行文件。说白了就是查找那些我们已经安装好的可以直接执行的命令

  whereis这个命令可以用来查找二进制（命令）、源文件、man文件。与which不同的是这条命令可以是通过文件索引数据库而非PATH来查找的，所以查找的面比which要广。

- ### 重载函数

  同一个函数名，但参数不一样，系统会根据你输入的参数类型或者参数的个数来判断要点用的函数。

  比如计算两数之和，整型和浮点型如果分开写的要写不同名的两个函数。但用重载函数的话就可以写两个重名的函数，只要参数类型或个数不一样就行，程程序执行会自动根据参数类型选择对应的函数。

  int-sum（int a，int b）

  float-sum（float a，float b）

  这两个就可以用函数重载

  sum（int a，int b）

  sum（float a，float b）

  这样不用记住众多不同名字的函数，记住一个sum就可以，只要参数类型或个数不一样就行

- ### API

  应用程序编程接口，其实就是通道，本质是一些预先定义的函数。让应用程式开发人员得以呼叫一组[例程](https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6))功能，而无须考虑其底层的原始码为何、或理解其内部工作机制的细节

  例如软件A想调用软件B的一些功能但又不想看B的源码和了解B的代码组成和功能，就可以通过B的API来实现，这些可以用B的功能而无需考虑源码。

- ### 密钥

  密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥。

- ### 命名空间namespace

  为了解决多个文件中可能会出现的对象重名现象。命名空间其实就是一个命名的范围区域，程序猿在这个特定的范围内创建的所有标识符都是唯一的。

  是解决命名冲突的最佳方式。例如：

  ```c++
  namespace Myname
  {
    int a=1;
  }
  namespace Myname1
  {
    int a=2;
  }
  ```

  这样Myname::a和Myname1::a就区分开了，是不同的标识符，表示不同的值。

  使用的话就用作用域限定符"::"

  `cout<<Myname::a<<endl;`

  如果使用using namespace …的话，就可以直接使用命名空间中的成员而不用加作用域限定符

  例如常用的using namespace std；就是用了命名空间std；中的成员，不然就得用std::cout

  std::cin，这样就比较麻烦。

- ### 编译的过程

  - 预处理。g++  -E  test.cpp  -o  test.i

    处理宏定义和头文件。将原文件test.cpp扩展为test.i文件

  - 编译。    g++  -S  test.i**(也可以用g++ -S test.cpp直接把.cpp变成test.s)**

    将c++代码转换为汇编代码。将预处理输出文件test.i会变成test.s

  - 汇编。    g++  -c  test.s**(同理也可以直接g++ -c test.cpp直接编译生成test.o)**

    将汇编语言翻译成机器指令。将汇编文件test.s变成test.o文件

  - 链接。   g++  test.o  -o  test

    将.o文件与.lib库文件链接生成可执行文件。生成可执行文件test

- ### 获取数组的长度

  通过使用sizeof函数，这个函数可以用来判断**数据类型**或者**表达式**的长度。

  典型的我们可以通过这个函数来获取数组的长度，例如int a[]={。。。。。。}，我们不知道数组的长度，当数据元素比较多数不过来或者定义的时候就没有说，那么**sizeof(a)/sizeof(int)**就是他的长度，因为int数组里面存储的都是int型数，所有全部的长度除以一个int的长度就是int数的个数。

- ### 函数声明，定义和调用

  int fun()；                 //这个叫函数的声明，只有函数的定义在main函数之后才需要用

  int main()

  {

  fun()；                  //函数调用

  }

  int fun()                  //函数定义

  {

  ……...

  }

  不能再函数中再定义函数；

- ### return语句就是返回函数值同时返回主函数继续运行，有一个return之后就退出了，不执行后面的return。

  ```c++
  #include"iostream"
  using namespace std;
  int A(int x)
  {
      if(x>10)
          return 10;
      return 5;
  }
  int main()
  {
  
      int x;
      cin>>x;
      int t=A(x);
      cout<<t;
      return 0;
  }
  ```

  如果输入15，那么函数就会返回10，而不会执行下面的return 5

- ### toil and moil 努力工作奋斗

- ### wax and wane 阴晴圆缺，事物的盛衰起落 

- ### CDN和cookie

  CDN的全称是Content Delivery Network，即内容分发网络，是通过在网络各处放置[节点服务器](https://baike.baidu.com/item/节点服务器/4576219)所构成的在现有的互联网基础之上的一层智能[虚拟网络](https://baike.baidu.com/item/虚拟网络/855117)，CDN系统能够**实时**地根据**网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息**将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。 

  cookie是网站存储在用户本地终端上的数据，Cookie是当你浏览某网站时，网站存储在你机器上的一个小文本文件，它记录了你的用户ID，密码、浏览过的网页、停留的时间等信息，当你再次来到该网站时，网站通过读取Cookie，得知你的相关信息，就可以做出相应的动作，如在页面显示欢迎你的标语，或者让你不用输入ID、密码就直接登录等 

- typora调整图片大小

  使用img标签

  ```text
   <img src="./xxx.png" width = "300" height = "200"  align=center />
  ```

  在我这儿src即为"image/1.jpg"
  
  不用点上面的插入图像，直接输出这个代码即可