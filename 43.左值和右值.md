c++中所有的值不是左值就是有值。简单来说等号左边的是左值，而等号右边是右值。

- 有名字的、可以取地址的就是左值，即在内存中占有位置。如变量名，int a=1，a就是左值而1就是右值。

  - **非常量左值引用很特殊，非常量左值引用只能由非常量左值（可以是引用也可以不是，下面第二种的函数那种情况比较特殊，必须是非常量左值引用  ）来赋值，**

    - int b=2；int &a=b；这是正确的，但是int &a=1是错误的。

    - ```c++
      friend ostream& operator<<(ostream& os,const Date t)
      {
         cout << "Month: " << t.iMonth << ' ' ;
         cout << "Day: " << t.iDay<< ' ';
         cout << "Year: " << t.iYear<< ' ' ;
         return os;
      }
      ```

      **这里形参列表里的os前的&不能去掉，函数返回的是左值引用，这儿return必须是左值引用，这种情况比较特殊。**

  - 常量左值引用可以用非常量左值，常量左值，也可以用右值，怎么都行，比较**万能**。

- 没名字、内存中没地址的就是右值。

- 有时二者是可以转换的

  int a = 1;     //a是一个左值
  int b = 2;     //b是一个左值
  int c = a + b; //＋需要右值，所以a和b都转换成右值，并且返回一个右值

- 经典的一个错误是：

  ```c++
  int foo() { return 2; }
  
  int main()
  {
      foo() = 2;
      return 0;
  }
  ```

  这里foo返回的是一个临时值2，而后面却尝试给一个右值赋值，显然是错误的。

  还有一个是

  ```c++
  int& foo()
  {
      return 2;
  }
  ```

  也是错误的，会提示` error: invalid initialization of non-const reference of type 'int&' from an rvalue of type 'int'`，是因为foo返回的是一个整型引用，即int&，是一个左值引用，而非常量左值引用只能用非常量左值引用赋值，这里却return 2；用一个右值给它赋值，因此错误。

  可以改为

  ```c++
  int reference =10;
  int& foo()
  {
  return reference;
  }
  ```

  这样就正确了。