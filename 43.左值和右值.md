c++中所有的值不是左值就是有值。左值和右值都是针对表达式而言的，左值是指表达式结束后依然存在的持久对象，右值是指表达式结束时就不再存在的临时对象。一个区分左值与右值的便捷方法是：看能不能对表达式取地址，如果能，则为左值，否则为右值。

- **有名字的、可以取地址的就是左值，即在内存中占有位置**。如变量名，int a=1，a就是左值而1就是右值。

  - **非常量（即前面没有加const）左值引用很特殊，非常量左值引用只能由非常量左值（可以是引用也可以不是 ）来赋值，**
- int b=2；int &a=b；这是正确的，但是int &a=1是错误的。
    - int a=1;int &b=a;int &c=b;

  - 对常量左值引用赋值时可以用非常量左值，常量左值，也可以用右值，怎么都行，比较**万能**。
  
- 没名字、内存中没地址的就是右值。

- 有时二者是可以转换的

  int a = 1;     //a是一个左值
  int b = 2;     //b是一个左值
  int c = a + b; //＋需要右值，所以a和b都转换成右值，并且返回一个右值

- 经典的一个错误是：

  ```c++
  int foo() { return 2; }
  
  int main()
  {
      foo() = 2;
      return 0;
  }
  ```

  这里foo返回的是一个临时值2，而后面却尝试给一个右值赋值，显然是错误的。

  还有一个是

  ```c++
  int& foo()
  {
      return 2;
  }
  ```

  也是错误的，会提示` error: invalid initialization of non-const reference of type 'int&' from an rvalue of type 'int'`，是因为foo返回的是一个整型引用，即int&，是一个左值引用，而非常量左值引用只能用非常量左值赋值，这里却return 2；用一个右值给它赋值，因此错误。

  可以改为

  ```c++
  int reference =10;
  int& foo()
  {
  return reference;
  }
  ```

  这样就可以给foo()赋值了。

#### 右值引用

左值引用必须要绑定左值（除了常量左值引用，这个比较特殊），那么相对的右值引用必须要绑定到右值。一个重要性质---右值引用只能绑定到一个将要销毁的对象，因此可以自由地将一个右值引用的资源“移动”到另一个对象中。

右值引用的符号是两个&

int &&a=1;a就是右值引用。

再比如

```c++
int add()
{
	return 1;
}
int &&a=add();
```

本来add()的返回值是右值，在表达式语句结束后生命就要终结了，而通过右值引用，它又重获新生，生命周期和右值引用类型变量a的生命周期一样。实际上就是给临时变量取了个名字。

但是从左右值的角度来讲，其实右值引用是一个左值，因为它可以被取地址

