## 动态规划

- #### 300.最长上升字序列

  这种上升子序列的用动态规划时，dp[i]一般定义为以nums[i]结尾的最长子序列。

  那么dp[i]就等于从0-i，以每一个小于nums[i]的元素为结尾的上升子序列的长度+1的最大值

  ```c++
   for(int i=1;i<n;i++)
          {
              for(int j=0;j<i;j++)
              {
                  if(nums[j]<nums[i])
                      dp[i]=max(dp[i],dp[j]+1);
              }
          }               
  ```

- #### 152.乘积最大子数组

  由于是乘法，所以不能用最大子序和那种方法，所以需要多一维变量来记录最大值和最小值，考虑正负数的问题

  **多一维变量来确保无后效性**

  max[i]表示以i结尾的子数组乘积的最大值

  ```c++
  class Solution {
  public:
      int maxProduct(vector<int>& nums) 
      {
          int n=nums.size();
          if(!n)
              return 0;
          if(n==1)
              return nums[0];
          vector<int> Max(n),Min(n);
  
          Max[0]=nums[0];
          Min[0]=nums[0];
          for(int i=1;i<n;i++)
          {
              if(nums[i]>=0)
              {
                  Min[i]=min(nums[i],nums[i]*Min[i-1]);  //nums[i]正数的话，最大值最小值乘以整数还是最大最小值
                  Max[i]=max(nums[i],nums[i]*Max[i-1]);
              }
              else
              {
                  Min[i]=min(nums[i],nums[i]*Max[i-1]);   //负数的话相反，最大值乘以负数变成最大值，最大值乘以负数变成最小值
                  Max[i]=max(nums[i],nums[i]*Min[i-1]);
              }
          }
          return *max_element(Max.begin(),Max.end());
      }
  };
  ```

- #### 198.打家劫舍Ⅰ

  dp[i]定义为偷到索引i是获得的最大利润，那么两种可能

  1. 偷i。那么dp[i]=dp[i-2]+nums[i]
  2. 不偷i。那么dp[i]=dp[i-1]

  取max即可

- #### 213.打家劫舍Ⅱ

  保存dp[i]的同时数组加一维，表示有没有强第一个房间

  ```c++
  class Solution {
  public:
      int rob(vector<int>& nums) 
      {
          int n=nums.size();
          if(nums.size()==0)
              return 0;
          if(nums.size()<4)
              return *max_element(nums.begin(),nums.end());
          vector<vector<int>> dp(nums.size(),vector<int>(2));
          dp[0][0]=0;     //表示没有抢第一个房间的情况下抢到i时的最大金额
          dp[0][1]=nums[0];
          dp[1][0]=nums[1];
          dp[1][1]=nums[0];
          
          for(int i=2;i<n;i++)
          {
              if(i!=n-1)
              {
                  dp[i][0]=max(nums[i]+dp[i-2][0],dp[i-1][0]);
                  dp[i][1]=max(nums[i]+dp[i-2][1],dp[i-1][1]);
              }
              else
              {
                  dp[i][0]=max(nums[i]+dp[i-2][0],dp[i-1][0]);
                  dp[i][1]=dp[i-1][1];
              }
          }
  
          
          return max(dp[n-1][0],dp[n-1][1]);
  
      }
  };
  ```

- #### 337.打家劫舍Ⅲ

  树状dp，使用二维数组，i表示到当前节点，j表示是否选中当前节点，`dp[i][j]`就表示从树底到当前节点可以获得的最大值

  因此要使用后序遍历，**我们的逻辑是子结点陆续汇报信息给父结点，一层一层向上汇报，最后在根结点汇总值**

  **可以用哈希，每个结点在两个哈希表中分别对应选中和不选中时的值，省去了数组的空间复杂度**

  ```c++
  class Solution {
  public:
      int rob(TreeNode* root) 
      {
          vector<int> res=dfs(root);
          return max(res[0],res[1]);     //每个节点都有一个对应的vector<int>,里面两个元素，第一个0是不包括root，第二个1表示包括root
          
      }
      vector<int> dfs(TreeNode* root)
      {
          if(!root)
              return {0,0};   //要返回2个元素，不能返回{}，不然上面的访问就会越界
          vector<int> left=dfs(root->left);
          vector<int> right=dfs(root->right);  //后序遍历，先得到子节点的vector，再根据子节点的vector生成父节点的vector
  
          int have=root->val+left[0]+right[0]; //选root的话，两个子节点就不能选
          int nothave=max(left[0],left[1])+max(right[0],right[1]);//不选root的话，就从子节点的选不选子节点中跳出大的那个
          return {nothave,have};
      }
  };
  ```

  哈希

  ```c++
  class Solution {
  public:
      unordered_map<TreeNode*,int> yes,no;   //yes,no
      int rob(TreeNode* root) 
      {
          dfs(root);
          return max(yes[root],no[root]);
      }
      void dfs(TreeNode* root)
      {
          if(!root)
              return ;
          
          dfs(root->left);
          dfs(root->right);
  
          yes[root]=root->val+no[root->left]+no[root->right];
          no[root]=max(yes[root->left],no[root->left])+max(yes[root->right],no[root->right]);
      }
  };
  ```

- #### 350.两个数组的交集

  利用哈希表记录次数，碰见一次减一次

  ```c++
class Solution {
  public:
      vector<int> intersect(vector<int>& nums1, vector<int>& nums2) 
      {
          vector<int> res;
          map<int,int> m;
          for(int i:nums1)
              m[i]++;
          for(int i:nums2)
          {
              if(m[i]>0)
              {
                  res.push_back(i);
                  m[i]--;
              }
          }
          return res;
      }
  };
  ```
  
- #### 128.最长连续序列

  - 使用unordered_set

    ```c++
    class Solution {
    public:
        int longestConsecutive(vector<int>& nums) 
        {
            unordered_set<int> a;
            for(auto i:nums)
                a.insert(i);
            int res=0;
            for(auto i:a)
            {
                if(a.count(i-1))  //如果存在比i-1更小的元素存在，那么i必然不是该局部最优解上升序列的开头
                    continue;
                int temp=1;
                while(a.count(i+1))
                {
                    temp++;
                    i++;
                }
                res=max(res,temp);
            } 
            return res;       
        }
    };
    ```
    
- **经典的并查集思路**
  
  使用map来做uf数组，注意cnt记录当前元素集合中元素个数，只会更新当前元素的cnt，并不是所有的都更新
    
  1. 将连续的数字作为一个集合
  2. 那么扫描到一个数字，只要将它和它的下一个数字（假如存在）merge在一个集合即可。同时更新这个集合的元素个数
    3. 如果当前经过merge的集合的元素个数比当前记录的最长序列的长度都长，则更新当前最长记录
    
    ```c++
    class Solution {
    public:
        unordered_map<int,int> uf,cnt; //uf为并查集的数组，初始时就是对应的数，cnt保存对应的集合的元素数目，但是要得到cnt必须是以该集合的root为key，因为unite的时候只更新了root对应的cnt
        int find(int x)   //寻找根节点
        {
            return x==uf[x] ? x : uf[x]=find(uf[x]); //寻根问祖，回把从x开始的都更新
        }
        
        int _union(int x,int y)
        {
            int c=find(x);
            int d=find(y);
            if(c==d)
                return cnt[c];
            uf[d]=c;
            cnt[c]+=cnt[d];
            return cnt[c];
        }
        int longestConsecutive(vector<int>& nums) 
        {
            if(nums.empty())
                return 0;
            for(int i:nums)
            {
                uf[i]=i;
              cnt[i]=1;
            }
          int ans=1;
            for(int i:nums)
            {
                if(i!=INT_MAX && uf.count(i+1))
                  ans=max(ans,_union(i,i+1));
            }
            return ans;
    
        }
    };
    ```
  
- #### 25.K个一组翻转链表

  先把要翻转的摘出来，然后反转完之后再接到原来的链子上

  官方题解的动图还可以

  ```c++
  class Solution {
  public:
      pair<ListNode*,ListNode*> reverse(ListNode* head,ListNode*tail)
      {
          ListNode *new_head=nullptr;
          ListNode *p=head;
          while(new_head!=tail)
          {
              ListNode *temp=p->next;
              p->next=new_head;
              new_head=p;
              p=temp;
          }
          return {tail,head};
  
      }
     
      ListNode* reverseKGroup(ListNode* head, int k) 
      { 
          ListNode* hair=new ListNode(0);   //hair指向链表头结点的前驱结点，所以可以一直保存原始链表
          hair->next=head;
          ListNode* pre=hair;
  
          while(head)
          {
              ListNode* tail=pre;   //pre即为要翻转的链表的前驱节点
              //判断剩下的长度还够K吗
              for(int i=0;i<k;i++)
              {
                  tail=tail->next;
                  if(!tail)
                      return hair->next;
              }
              
              ListNode* nex=tail->next;  //保存后继，到时候能找回来
              pair<ListNode*,ListNode*> result=reverse(head,tail);
              head=result.first;
              tail=result.second;
  
              pre->next=head;   //前面接上
              tail->next=nex;   //后面接上
  
              pre=tail;         //pre继续保存前驱
              head=tail->next;  //head即为下一组翻转链表的头节点
          }
          return hair->next;
      } 
  };
  ```

- #### 105.从前序与中序遍历序列构造二叉树

  二叉树的构造一定是利用递归来完成的，同时注意中序和前序的特点，前序的第一个结点即为根节点，那么对应到中序里就可以把左子树和右子树分开

  ```c++
  class Solution {
  public:
      map<int,int> m;
      TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) 
      {
          int n=preorder.size();
          for(int i=0;i<n;i++)
              m[inorder[i]]=i;     //把中序的索引保存起来，这样后面用前序中的元素为key找它在中序中的位置时直接一查就可以
  
          return build(preorder,inorder,0,n-1,0,n-1);
      }
      TreeNode* build(vector<int>& preorder,vector<int>& inorder,int preorder_left,int preorder_right,int inorder_left,int inorder_right)
      {
          if(preorder_left>preorder_right)
              return nullptr;
          
          int inorder_root=m[preorder[preorder_left]];  //中序中根节点的位置
  
          //构造根节点
          TreeNode* root=new TreeNode(preorder[preorder_left]);
          int child_tree_size=inorder_root-inorder_left;
          root->left=build(preorder,inorder,preorder_left+1,preorder_left+child_tree_size,inorder_left,inorder_root-1); 
          root->right=build(preorder,inorder,preorder_left+1+child_tree_size,preorder_right,inorder_root+1,inorder_right); //索引最好用加不要用减
          return root;
      }
  };
  ```

- #### 剑指offer17 

  使用字符串记录

  ```c++
  class Solution {
  public:
      vector<int> res;
      vector<int> printNumbers(int n)
      {
          if(n<=0)
              return res;
          string a(n,'0');
          for(int i=0;i<10;i++)
          {
              a[0]=i+'0';  //每一位有10种选择
              nextDigits(a,n,1);
          }
          return res;
      }
      void nextDigits(string& a,int n,int index)
      {
          if(index==n)
          {
              save(a);  //只有==n才算完成了一次排列，才能输出
              return;
          }
          else
          {
              for(int i=0;i<10;i++)
              {
                  a[index]=i+'0';
                  nextDigits(a,n,index+1);
              }
          }
      }
      void save(string a)
      {
          string temp;
          auto it=a.begin();
          while(*it=='0')
              it++;
          while(it!=a.end())
          {
              temp+=*it;
              it++;
          }
          if(temp!="")   //排除string里全是0的情况
              res.push_back(stoi(temp));
      }
  
  };
  ```

- #### 32.最长有效括号

  动态规划建立状态方程

  dp[i]表示以以i结尾的子序列的最大有效长度，那么左括号的全为0

  右括号有两种情况：

  1. 前一个是左括号

     那么dpi=dpi-2  +2(i>=2的情况下)

  2. 前一个是右括号

     那么i对应的右括号对应的左括号的位置为i-dp[i-1]-1，即dp[i-1]有效序列的前一个位置，如果这个位置是左括号，那么结果就等dp[i-1]+2,同时还有考虑再前一个位置它的有效长度，即i-dp[i-1]-1-1这个位置

  ![](image/142.jpg)

  ```c++
  class Solution {
  public:
      int longestValidParentheses(string s) {
          int size = s.length();
          vector<int> dp(size, 0);
  
          int maxVal = 0;
          for(int i = 1; i < size; i++) 
          {
              if (s[i] == ')') 
              {
                  if (s[i - 1] == '(') 
                  {
                      dp[i] = ((i-2>0)?dp[i-2]:0)+2;
                  } 
                  else if(i-dp[i-1]-1>=0&&s[i-dp[i-1]-1]=='(')
                  {
                      dp[i] = dp[i - 1] + ((i - dp[i - 1] - 2 >=0)?(dp[i - dp[i - 1] - 2]):0) + 2 ;                  
                  }
              }
              maxVal = max(maxVal, dp[i]);
          }
          return maxVal;
      }
  };
  ```

- #### 50.实现pow(x,n)

  递归，每次把n分成一半，在根据n的奇偶性判断要不要再乘一个x

  ```c++
  class Solution {
  public:
      double myPow(double x, int n) 
      {
          if(n==0)
              return 1;
          if(n==1)
              return x;
          if(n==-1)     //处理n时负数的情况
              return 1/x;
          double half=myPow(x,n/2);
          double rest=myPow(x,n%2);   
          return rest*half*half; 
      }
  };
  ```

- #### 面试题08，09

  dfs，注意剪枝，右括号不能比左括号多同时一种括号个数不能大于一半

- #### 剑指offer12.矩阵的路径

  dfs，设置方向数组，然后每次把遍历过的修改为@，遍历完之后再改回来

- #### offer13.机器人的运动范围

- #### offer14 .剪绳子1和2，性质类似于整数拆分343题

  动态规划和贪心

  取模的时候。第三个，所有的都乘完再取模，等于每个都取模相乘，最后结果再取模

  ![image-20200723201801509](image/image-20200723201801509.png)

- #### 231.  2的幂  还有3、4的幂

  1. 对于2，因为2的幂的二进制数中只有一位是1，所以n&n-1必然是0，可以通过这个结果判断
  2. 通过换底公式 log10(n)/log10(2),然后用floor函数下取整看是不是相等
  3. 逆向思维，可以设置a位1然后一直乘以底数

- #### 50.pow  快速幂 递归和非递归

  1. ```c++
     class Solution {
     public:
         double myPow(double x, int n) 
         {
             if(n==0)
                 return 1;
             if(n==1)
                 return x;
             if(n==-1)
                 return 1/x;
             double half=myPow(x,n/2);  //每次把指数减半
             double rest=myPow(x,n%2);  //指数是偶数的话乘1，指数是奇数就再乘一个底数
             return rest*half*half; 
         }
     };
     ```

  2. ```c++
     //非递归快速幂
     long long  qpow(long a, long n){
         long long ans = 1;
         while(n){
             if(n&1)        //如果n的当前末位为1
                 ans *= a;  //ans乘上当前的a
             a *= a;        //a自乘
             n >>= 1;       //n往右移一位
         }
         return ans;
     }
     ```

- #### 136.亦或运算

  只出现一次的数字，利用异或的性质

- #### 191.二进制中1的个数

  1. n&1然后n移位。正数的话这样是可以的，因为移位的话两边都会补0，但是负数的话右移补符号位1，这样最终会死循环
  2. n不动，1移位和n与，这样正数负数都可以用
  3. n和n-1与，会消去n中最右边的一个1，有几个1就消几次，即循环几次

- #### 169.摩尔投票

  多数元素，超过一半

- #### 202.快乐数  

  快慢指针找环。可以证明所有的叔最终都会快乐循环，那么双指针相遇的时候就是在环里，如果这个元素是1，环上如果有一个1，那么所有的都是1，即满足快乐数的要求；如果不是1，证明环路上不存在1，即无限循环但是到不了1，即不是快乐数

  <img src="image/image-20200809200314855.png" alt="image-20200809200314855" style="zoom:67%;" />

- #### 287.重复数

  floyd判圈算法，利用边i->nums[i]构造图，那么重复的数target至少有两个索引都指向它，即链表存在回路，那么重复的数即为环的入口那个数

  抽象成链表找环的入口，快慢指针

- #### 104.二叉树的最大深度

  递归左右子树

- #### 110平衡二叉树

  利用了104求深度的函数，自上而下，先判断根节点的左右子树高度差然后递归左右子树

- #### offer57.和为s的两个数字

  第一题的哈希表的方式

  双指针，一前一后开始开始遍历

- #### offer 57-Ⅱ.和为s的连续正数序列

  滑动窗口

- #### offer 58 -Ⅰ

  通过stringstream和substr，stringstream>>a和cin一样会自动跳过空格回车等字符

- #### 263.丑数

  循环的除以235，如果是丑数那么最后一定能除到1，循环时如果num不是1而且不能被235整除，那就不是丑数

- #### 264.丑数-Ⅱ

  使用小顶堆是先存进去然后自动排序，而使用动态规划是先排序，然后把最小的存进去

  **利用的原理都是后面的丑数都是前面的丑数乘以2.3.5得到的。**

  ```c++
  
  class Solution {
  public:
      int nthUglyNumber(int n)
      {
          vector<int> dp(n);
          dp[0]=1;
          int p2=0,p3=0,p5=0;
          for(int i=1;i<n;i++)
          {
              dp[i]=min(min(dp[p2]*2,dp[p3]*3),dp[p5]*5);
              if(dp[i]==dp[p2]*2)
                  p2++;
              if(dp[i]==dp[p3]*3)
                  p3++;
              if(dp[i]==dp[p5]*5)
                  p5++;
          }
          return dp[n-1];
      }
  };
  ```

- #### 88.合并有序数组

  1. 从前往后，利用归并的思想，但是使用额外空间
  2. 从后往前，进行比较赋值，不使用额外空间
  
- #### 4.寻找有序数组的中位数

  下面这种仅适用于找中位数，可以修改之后变成通用的

  ```c++
  class Solution {
  public:
      double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) 
      {
          if(nums1.size()>nums2.size())
              swap(nums1,nums2);
          
          int m=nums1.size();   
          int n=nums2.size();
  
          int leftNum=(m+n+1)/2;  //如果m+n是奇数的话，那么+1表示把中位数放到左边部分，那么中位数就是左边中最多的数。如果m+n是奇数的话，那么+1不影响结果，这儿我们定义为放到左边，当然也可以不加1放到右边，最后取结果的时候根据情况处理就行。
          
          int left=0;
          int right=m; //是m而不是m-1是因为要考虑到nums1数组的所有元素都在分割线的左边，下面的二分里i表示的是索引i位于分割线右边，即i表示分割线左边元素的个数，要保证能把所有的元素都放到左边，i就要能取到m这个值
          
  
          ////要在[0,m]中找分割线，而且符合条件的分割线就一条，这些写二分查，就算找到过==的也不会返回，会一直缩小返回，最后返回的结果是满足条件和不满足条件的交界处，即nums1[i-1]>nums2[j]和nums1[i-1]<=nums2[j]，设前面的条件是A，后面的B，那么返回的就是B中最靠近A的那一个，因为中位数的线只有一条，那么返回的这条即为所求的
          while(left<right)
          {
              int i=left+(right-left+1)/2;
              int j=leftNum-i;
              if(nums1[i-1]>nums2[j])   //+1之后mid访问不到左边界，所以i-1不会越界,所以下面要通过i-1来访问左边界
                  right=i-1;
              else
                  left=i;
          }
  
          int i=left;
          int j=leftNum-i;
          
          int nums1LeftMax=i==0?INT_MIN:nums1[i-1];
          int nums1RightMin=i==m?INT_MAX:nums1[i];
          int nums2LeftMax=j==0?INT_MIN:nums2[j-1];
          int nums2RightMin=j==n?INT_MAX:nums2[j];
  
          if((m+n)%2==0)
              return (double)(max(nums1LeftMax,nums2LeftMax)+min(nums1RightMin,nums2RightMin))/2;
          else
              return max(nums1LeftMax,nums2LeftMax);
      }
  };
  ```

  > 要在[0,m]中找分割线，而且符合条件的分割线就一条，这样写二分查，就算找到过==的也不会返回，会一直缩小返回，最后返回的结果是满足条件和不满足条件的交界处，即nums1[i-1]>nums2[j]和nums1[i-1]<=nums2[j]，设前面的条件是A，后面的B，那么返回的就是B中最靠近A的那一个，因为中位数的线只有一条，那么返回的这条即为所求的

  #### **求有序数组的第K小的数**

  首先确定二分的范围，前面求中位数的话就在[0,m]二分，但是我们求K的话需要限制。m和n分别为两个数组的

  <img src="image/image-20200805201637150.png" alt="image-20200805201637150" style="zoom:50%;" />

  ```c++
  int findK(vector<int>& a,vector<int>& b,int k)
  {
      int m=a.size();
      int n=b.size();
  
      int l=max(0,k-n);   //这儿限定范围之后就不用再管数组的谁长谁短访问越界了
      int r=min(m,k);
  
      while(l<r)
      {
          int i=l+(r-l+1)/2;
          int j=k-i;
          if(a[i-1]>b[j])
              r=i-1;
          else
              l=i;
      }
  
      int i=l;
      int j=k-i;
      int nums1LeftMax=i==0?INT_MIN:a[i-1];
      int nums2LefrMax=j==0?INT_MIN:b[j-1];
      return max(nums1LeftMax,nums2LefrMax);
  }
  ```

- 

