### 类的虚表

虚函数即函数声明前加**virtual**关键字的函数，每个包含虚函数的类都包含一个虚表。当一个类（B）继承类（A）时，类B会继承类A的函数的调用权。所以如果一个基类包含了虚函数，那么继承类也可以调用这些虚函数，因此如果B有虚函数，有虚表，那么从B继承的A也有自己的虚表

 如下面的类A，其中有虚函数vfunc1和vfunc2，因此A拥有一个虚表

```c++
class A
{
    public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
    private:
    int data1,data2;
}   
```

<img src="image/35.png" style="zoom:50%;" />

虚表本质上是一个指针数组，其元素是虚函数的指针，每个指针指向一个虚函数。而普通函数是不会存储在虚表中的。

虚表中指针的赋值是发生在编译器的编译阶段，也就说在代码的编译阶段，虚表就构建出来了。

### 虚表指针

虚表是属于类的，而不属于某个具体的对象，一个类只需要一个虚表，同一个类的所有对象都使用同一个虚表。

为了指定对象所用的虚表，对象在调用构造函数初始化时，会定义一个虚表指针`_vptr`，指向构造函数所属类的虚表（会指向最近的构造函数，例如子类对象初始化时会先调用父类的构造函数，再调用子类的构造函数，这时对象的虚表指针会指向最近的构造函数所属类的虚表，即子类的虚表）。

<img src="image/36.png" style="zoom:50%;" />

### 动态绑定

```c++
class A {
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int m_data1, m_data2;
};

class B : public A {
public:
    virtual void vfunc1();
    void func1();
private:
    int m_data3;
};

class C: public B {
public:
    virtual void vfunc2();
    void func2();
private:
    int m_data1, m_data4;
};
```

A是基类，B从A继承，C又从B继承，其对象模型如下

<img src="image/37.png" style="zoom:50%;" />

**对象的虚表指针用来指向自己所属类的虚表，虚表中的指针会指向其继承的最近的一个类的虚函数**

现在我们声明一个类B的对象

```c++
int main()
{
    B bObject;
}
```

现在用一个类A的指针指向bObject，然后调用vfunc1()函数

```c++
int main()
{
    B bObject;
    A *p=&bObject;
    p->vfunc1();
}
```

调用的是B::vfunc1()

首先指针p指向对象bObject，而bObject的虚表指针`_vptr`指向的是类B的虚表，因此调用vfunc1()即调用`B::vfunc1()`

---

### Q&A

#### 构造函数可以声明为虚函数吗？

显然构造函数是不能声明为虚函数的。
我们知道，在调用虚函数前，需要先访问虚表指针，得到虚表，然后再执行虚表中相对应的函数。假设，现在将构造函数声明为虚函数：调用构造函数时，发现构造函数是一个虚函数，然后去访问虚表指针，可是虚表指针是在构造函数中进行初始化的，而目前构造并没有执行，也就是说，虚表指针还没有初始化，只是一个空值，理所当然的，也就找不到指向构造函数的函数指针，因此无法完成构造函数的调用。可见，构造函数是不能声明为虚函数的。

#### 析构函数可以声明为虚函数吗？

**1、当然是可以的，而且，为了防止内存泄漏，基类的析构函数必须声明为虚函数！**
**2、为什么将基类析构函数声明为虚函数，就可以防止内存泄漏？**

如果没有将基类析构函数声明为虚函数，在释放**指向派生类对象的基类指针**的时候，只会调用基类的析构函数，而派生类的析构函数不会被调用，导致属于派生类的新添加的数据得不到释放，从而导致内存泄漏。
如果将析构函数声明为虚函数，在释放**指向派生类对象的基类指针**的时候，会调用派生类的析构函数，而派生类的析构函数会自动调用基类的析构函数，从而释放所有内存，避免了内存泄漏。
**3、可是，有个问题，为什么将基类析构函数声明为虚函数之后，在释放指向派生类对象的基类指针时，调用的是派生类的析构函数？难道派生类的析构函数重写了基类的析构函数？不可能啊，基类析构函数和派生类析构函数的函数名不同，不能构成重写啊。**

其实，析构函数是一个特殊的函数，编译器在编译时，析构函数的名字统一为destucter；
所以只要将基类的析构函数声明为虚函数，不管子类的析构函数前是否加virtual，都构成重写。这也就可以解释为什么将基类析构函数声明为虚函数，释放指向派生类对象的基类指针时，会调用派生类的析构函数，因为虚表中的函数指针指向的是派生类的析构函数。

