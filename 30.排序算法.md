![](image/33.png)

- #### 冒泡排序

  主要是通过两层循环，

  - 外循环一共进行len-1次，每次得到一个最大的数放在下面，10个数的话就遍历9次。

  - 内循环是每次遍历比较的次数，为len-i次，i是第i次遍历。10个数的话第一次遍历就比较10-1=9次。

    ```c++
    int main()
    {
        int a[]={2,8,3,1,9,4};
        for(int i=0;i<sizeof(a)/sizeof(int)-1;i++)
        {
            int temp;
            for(int j=0;j<sizeof(a)/sizeof(int)-i-1;j++)
            {
               if(a[j]>a[j+1])
               {
                   temp=a[j+1];
                   a[j+1]=a[j];
                   a[j]=temp;
               }
            }
        }
        return 0;
    }
    ```

- #### 选择排序

  也是两层循环

  - 第一层也是和冒泡排序一样进行len-1次，每次排序得到最小的一个数放在最前面
  - 内层就是以剩下的元素中第一个为基准进行比较，如果小就换位置，不小就跳过

  > 和冒泡排序比较像
  >
  > - 相同点：每一轮都把最大或者最小的元素筛选出来放在相应的位置上
  > - 不同点：对于每一轮，冒泡排序每次比较和移动相邻的两项；而选择排序比较和交换的是当前项和第n项

  ```c++
  int main()
  {
      int a[]={2,8,3,1,9,4};
      for(int i=0;i<sizeof(a)/sizeof(int)-1;i++)
      {
          for(int j=i+1;j<sizeof(a)/sizeof(int);j++)
          {
              if(a[j]<a[i])
              {
                  int temp=a[j];
                  a[j]=a[i];
                  a[i]=temp;
              }
          }
  
      }
      for(int i=0;i<6;i++)
      {
          cout<<a[i];
      }
      return 0;
  }
  ```

- #### 插入排序

  就是将元素插入到有序数组中。默认第一个元素为有序数组，剩下的为无序数组。然后从第二个开始往前面插，每次有序数组多一个，无序数组少一个

  ```c++
  int main()
  {
      int a[]={2,8,3,1,9,4};
      int j;
      for(int i=1;i<sizeof(a)/sizeof(int);i++)
      {
          int temp=a[i];
          for(j=i-1;j>=0;j--)
          {
              if(temp<a[j])
                  a[j+1]=a[j];
              else
                  break;
          }
          a[j+1]=temp;
      }
      for(int i=0;i<sizeof(a)/sizeof(int);i++)
      {
          cout<<a[i];
      }
      return 0;
  }
  ```
  
- #### 快速排序

  https://blog.csdn.net/qq_28584889/article/details/88136498

  ```c++
  //快速排序（从小到大）
  void quickSort(int left, int right, vector<int>& arr)
  {
  	if(left >= right)
  		return;
  	int i, j, base, temp;
  	i = left, j = right;
  	base = arr[left];  //取最左边的数为基准数
  	while (i < j)
  	{
  		while (arr[j] >= base && i < j)   //先从最左边开始，找小于base的。这儿一定要找小于base的，不能带等号
  			j--;
  		while (arr[i] <= base && i < j)    //然后从右边开始找大于base的
  			i++;
  		if(i < j)
  		{
  			temp = arr[i];
  			arr[i] = arr[j];
  			arr[j] = temp;
  		}
  	}
  	//基准数归位
  	arr[left] = arr[i];
  	arr[i] = base;
  	quickSort(left, i - 1, arr);//递归左边
  	quickSort(i + 1, right, arr);//递归右边
  }
  ```

- 