- ### DNS（Domain Name System，域名系统）

  域名，网址，URL
    eg. www.baidu.com
    域名 baidu.com
    URL(俗称网址） www.baidu.com

- ### RFC 

   Request For Comments（RFC），是一系列以编号排定的文件。文件收集了有关互联网相关信息，以及UNIX和互联网社区的软件文件。

- 如果人民害怕政府，这就是暴政；如果政府害怕人民，这就是自由。  ——托马斯·杰斐逊

- 我慢慢地、慢慢地了解到，所谓父女母子一场，只不过意味着，你和他的缘分就是今生今世不断地在目送他的背影渐行渐远。你站立在小路的这一端，看着他逐渐消失在小路转弯的地方，而且，他用背影默默告诉你：不必追

- 真值，补码，反码，移码

  到目前为止，我们学习了十进制、二进制、八进制、十六进制等用来代表实际数值的数，称为真值。
  正数的原码，反码，补码都是一致的就是前面加了个0表示正数。
  负数的（1）原码要在前面加个1表示表示是负数。
  ​            （2）反码除符号位外全部取反。
  ​            （3）补码除符号位以外剩下的取反加一。

   移码:对正数而言就是把符号位取反就可以了，对负数而言就是所有的位（包括符号位）取反加一。

   0的表示形式   原码: [+0]原=0000000  [-0]原=1000000
  ​                         反码: [+0]反=0000000  [-0]反=11111111
  ​                         补码: [+0]补=0000000  [-0]补=0000000
  ​                         移码: [+0]移=1000000  [-0]移=1000000

- 人们往往不相信暴虐粗糙的口诛笔伐，而相信和颜悦色的别有用心。

- ### BT

  即bittorrent。比特流。是一种传输协议。有特定后缀的BT文件也有特定的下载方式，下载的人的越多，速度越快。

- ### 平假名和片假名

  平假名主要是用来表示日本固有的一些文字，说是平其实看着拐弯那种

  片假名是用来表示外来语等，看起来横平竖直不拐弯

- ### 给时光以生命，而不是给生命以时光

  To the time to life,rather than to life in time

  时间是不会停止没有感情的，我们应该把握时间，把自己丰富多彩的人生系在时间线上，而不是用空洞毫无亮点的时间来填充我们的生命历程

- ### 固态硬盘那些事

  - 总线标准，是数据传输方式，也可以叫通道：PCI-E、SATA、并口（PATA）

    并口（PATA）对应的是IDE协议，为旧机械硬盘量身定做

    串口（SATA）对应的是AHCI协议，为新机械硬盘量身定做（为了缩短磁盘寻道时间）；

    扩展串口（PCIe） 对应的是NVMe协议，为厉害的固态硬盘量身定做

  - 物理接口：SATA、M.2

     其实物理接口用什么和速度是没什么关系的，如果是SATA接口那么就是使用SATA通道走AHCI协议。而M.2接口有两种接口模式socket2和socket3，socket2对应的接口是bkey，对应的是传输模式为sata,如果用这个话那么用M.2物理接口和SATA是没有区别的。而socket3对应的接口是mkey，走的是PCI-e，这个时候才用的是更快的PCI-e。注意，走pcie不等同于支持nvme，pcie硬盘也有支持AHCI的

  -   传输协议：AHCI、NVMe

      PCIE相比SATA有更快的速度，SATA总线一般采用AHCI协议，而PCIE一般使用NAMe协议。

      但需要注意的是使用NVMe的一定使用PCI-e，但是使用PCI-e的未必使用Nvme，也可能使用AHCI

      目前来看PCI-e搭配NVMe是最快的

  - **<u>*总结</u>***：ssd的快慢和物理接口用什么没哈关系，主要看通道的选择和传输协议的选择，使用PCI-e的比SATA的更快，而且使用PCI-e的里面使用NVMe的最快

- ### 渲染render（给予，呈现，递交，表达）

  - 存在于CG领域，电脑绘图中以软件由模型生成图像的过程，通俗理解就是绘制，其实把render直接翻译为绘制更好，就是把场景画出来的意思。
  - 我们平常说的渲染视频是一个过程，把一个视频进行各种处理添加字幕音乐等等等，把这些内容整合到一个完整的符合某个视频格式的视频文件中的过程就叫做渲染，也可以叫整合输出吧。

- 天体测量距离用视差法和光谱法，有点复杂的

- 计算密集型和IO密集型

   - **CPU密集型（CPU-bound）**

     CPU密集型也叫计算密集型，指的是系统的硬盘、内存性能相对CPU要好很多，此时，系统运作大部分的状况是CPU Loading 100%，CPU要读/写I/O(硬盘/内存)，I/O在很短的时间就可以完成，而CPU还有许多运算要处理，CPU Loading很高。

     在多重程序系统中，大部份时间用来做计算、逻辑判断等CPU动作的程序称之CPU bound。例如一个计算圆周率至小数点一千位以下的程序，在执行的过程当中绝大部份时间用在三角函数和开根号的计算，便是属于CPU bound的程序。

     CPU bound的程序一般而言CPU占用率相当高。这可能是因为任务本身不太需要访问I/O设备，也可能是因为程序是多线程实现因此屏蔽掉了等待I/O的时间。

   - **IO密集型（I/O bound）**

     IO密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作，大部分的状况是CPU在等I/O (硬盘/内存) 的读/写操作，此时CPU Loading并不高。

     I/O bound的程序一般在达到性能极限时，CPU占用率仍然较低。这可能是因为任务本身需要大量I/O操作，而pipeline做得不是很好，没有充分利用处理器能力。

   - **CPU密集型 vs IO密集型**

     我们可以把任务分为计算密集型和IO密集型

     - 计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。

       **计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。**

     - 第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。

       IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。

       总之，计算密集型程序适合C语言多线程，I/O密集型适合脚本语言开发的多线程。

- ### P问题，NP问题，NPC问题。

   - P问题：在多项式时间（即O(n^k)，k是常数，依问题而定）内能解决的问题。超多项式时间如指数，阶乘等。

   - NP问题：可以在多项式时间里验证一个解。即可以在多项式时间内猜看给定的这个解对不对。(显然P属于NP)

   - NPC问题（NP完全问题）：首先是NP问题，其次所有的NP问题都能约化（**A问题的解法是B问题的一种特例，则A可以归约出B，但要注意复杂度是A<=B。一个问题约化为另一个问题，时间复杂度增加了，问题的应用范围也增大了。通过对某些问题的不断约化，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替复杂度虽然低，但只能用于很小的一类问题的算法。联想起约化的传递性，如果不断地约化上去，不断找到能“通吃”（即复杂度>=所有的NP问题）若干小NP问题的一个稍复杂的大NP问题，最后能找到一个时间复杂度最高，并且能“通吃”所有的 NP问题的这样一个超级NP问题，这样的问题就是NPC问题**）成它，当然不仅仅一个，是一类问题（他们之间复杂度取等号）。所有的NP问题都能在多项式时间内转化成NPC问题。

     证明一个问题是 NPC问题也很简单。先证明它至少是一个NP问题，再证明其中一个已知的NPC问题能约化到它。（注意找规约是找复杂度>=它的，如果不是NPC要找NPC的话就找>它的；如果是要从已知的NPC证它是NPC的话，就要取等号了，它和已知的NPC问题有相同的复杂度，都是最高的，那它也是NPC问题）现在已经有很多已证明是NPC问题的NP问题。

   - 现在要证明的P是否等于NP就是看P和NPC的关系，就是看NPC问题能否在多项式时间内求解。因为所有的NP问题都可以约化到NPC问题，一旦证明P=NPC，即NPC问题可以在多项式时间内求解，自然就证明了NP问题可以在多项式时间内求解。

     > SAT即布尔可满足性问题，也是第一个被证明的NP完全问题。
   
- ### brew

   类似于ubuntu上apt-get，可以实现包管理而不用关心各种依赖和文件路径的情况，简单的一些操作

   - 安装包  brew install <packagename>
   - 卸载包  brew uninstall <packagename>
   - 查询可用包 brew search <packagename>
   - 查询已安装列表 brew list
   - 查询任意包的信息 brew info <packagename>
   - 更新homebrew  brew update
   
- ### 32位和64位

   **即操作系统的位数，也叫字长，是计算机内寻址总线的位数，即一次处理的数据位数。**它决定了虚拟地址的地址空间的最大大小，字长为32位即虚拟地址的范围为0~2^32-1，即最大4GB，而虚拟存储器是对程序存储器也就是主存(也叫内存)的一种抽象，因此32位最多支持4GB物理内存。同样63位就支持2^32GB的内存。但实际使用时不会把所以的物理存储全给内存，IO设备也要用到一部分，因此实际用回比理论的少。
   
- ### RGB

   RGB色彩模式是工业界的一种颜色标准，通过对红(R)，绿(G)，蓝(B)三个颜色通道的变化以及他们的相互之间的叠加得到各种各样的颜色。

   通常情况下，RGB各有256级亮度，从0到255，因此三种颜色可以组合出256✖️256✖️256=16777216种颜色。通常被简称为1600万色或千万色，也成24位色(2的24次方)。

- ### *和&运算

   **通俗说*是取指针所指地址的对应的值，而&是取变量对应的地址。**

   **（*p）操作是这样一种运算，返回p 的值作为地址的那个空间的取值。即返回p地址所指的值。**

   **（&p）则是这样一种运算，返回当时声明p 时开辟的地址。即取p的地址**

   int a=1                    (1)

   int *p=&a               (2)

   int c=*p                  (3)

   int **p1=&p;         (4)

   int d=**p1             (5)

   - 其中p为整型指针，它的值必须为地址，因此不能直接赋予a的值，而应该赋予一个地址，所以就用&a来取a的地址赋值给p。
   - 2式表明p为整型指针，指向a，那么int c=*p就是取指针p所指地址对应的的值
   - 4式表明p1为一个二级指针，指向p，那么5式中的**p1就是取p1所指的地址对应的指针所指的地址对应的值。

- ### 逻辑运算符与位运算符

   - 逻辑运算符即只判断逻辑真确还是错误，即&&，||和！。逻辑运算认为所有非零的参数都表示true，而参数零表示false。它最后表示的结果要么是true要么是false，分别返回1或者0

     0x11&&0x22=0x01

     0x11&&0x00=0x00

   - 位运算符就是要一位一位的运算，即&，|和~。最后得到一个计算得出的结果。

- ### void的用法

   ###### main函数需要返回值，以前还可以用void main 现在不能用了，最好用int main然后结果加个return 0.或者写成int main(void)也是可以的。

- ### 不同的输出形式代表的意义

   c1='a';

   cout<<c1<<endl;     a

   cout<<'c1'<<endl;     25393.  Ox63 ox32,然后ox6332转换成十进制数就是25393

   cout<<"c1"<<endl;   c1    双引号里面是啥就输出啥

   cout<<int(c1)<<endl;   97  将字符型强制转换成整形，输出c1赋值字符的ascii值对应的十进制数。

   **<u>以上只是在c1=‘a’这种情况下的输出并不具有普适性，如果变成c='a'的话结果有不一样了</u>**

   c='a';

   cout<<c;          a     这个不用多说，这个变量的值是什么就输出什么，整型就整型，字符就字符

   cout<<'c';        c      这个和上边的就有区别了，如果里面刚好是一个字符或数字即存在于ascii表里面的单个的，那就直接输出这个数字或字符。但是如果不止一个，那就麻烦了，要把这些字符或者数字转换成ascii值然后按顺序组成一个十六进制数然后输出对应的十进制数。

   cout<<"c";       c      和上面一样

   cout<<int(c);   97    

   cout<<int('c');  99      这种强制类型转换的，如果没有单引号的话转的就是变量赋于的初值的ascii值变量是多少就转多少。如果有了单引号之后就和原来的变量是多少没多大联系了，直接把变量的名当成字符或者字符串来转。

   > 总结一下，
   >
   > - 如果没有引号那么原来是啥就输出啥；
   > - 如果加了单引号就要看里面是不是单个的字母或数字，是的话直接输出该字母或数字，如果不是的话即里面有不止一个字母或者数字或者二者混合，那就把他们按顺序一个一个转成ascii值再按顺序组合成一个hex数，最后输出这个数对应的十进制数。
   > - 如果加双引号的话里面是啥就输出啥。
   > - 如果是强制类型转换，没有单引号的话转的就是变量被赋于的初值的ascii值；有单引号的话，不管里面是一个还是多个都是转ascii值再转十进制（这里就是对于单个字符或者数字的时候和2的处理方式不一样，在这里单个多个都是按照同样的方式处理）
   >
   > **<u>总之一但有单引号那就和变量的初值没啥关系了就看这个字符或者字符串本身！！！！！！</u>**

- ### 静态变量和函数

   - static 全局变量和普通的全局变量的区别：

     ```
     前者只能初始化一次。  
     ```

   - static 局部变量和普通的局部变量的区别：

     ```
     static 局部变量只被初始化一次，下一次的运算依据是上一次结果值；
     ```

   - static 函数与普通函数的区别：

     ```
     作用域不一样，static 函数只在一个源文件中有效，不能被其他源文件使用；
     ```

- ### C++中三目运算符的意义

   三目运算符 <表达式1>?<表达式2>:<表达式3>

   先判断表达式1的逻辑值，如果逻辑值为真则整个式子的运算结果为表达式2的值；如果为假，则整个表达式的运算结果为表达式3的值。

- ### 原补反移码

   正数的原码、补码、反码和移码皆相同；对于负数而言，反码是除符号位以外全部取反，补码是除符号位以外取反加1，移码是连同符号为取反加1。简言之负数原码除符号位取反变成反码，反码加1变成补码，补码的符号为取反就变成移码。

- ### 单精度和双精度浮点数的十进制有效位数及误差出现的条件

   V=(-1)^s ✖️M✖️2^E

   s符号，M尾数，E阶码

   float

   符号1位

   尾数23位

   阶码8位

   double

   符号1位

   尾数52位

   阶码11位

   如果是十进制七位数（包括7）以内小数就用float，超过了就用double（double有16位）。

   > 单精度数的尾数用23位存储，加上默认的小数点前的1位1，2^(23+1) = 16777216。
   >
   > 因为 10^7 < 16777216 < 10^8，所以说[单精度浮点数](https://www.baidu.com/s?wd=%E5%8D%95%E7%B2%BE%E5%BA%A6%E6%B5%AE%E7%82%B9%E6%95%B0&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)的有效位数是7位。 
   >
   > 双精度的尾数用52位存储，2^(52+1) = 9007199254740992，
   >
   > 因为10^16 < 9007199254740992 < 10^17，所以双精度的有效位数是16位.

   但是由于十进制小数转换为二进制时存在除不尽的情况，因此即使没有超过有效位数也可能出现误差，但如果能除尽就不会有了。eg float 2.25能除尽就没有，但是1.515除不尽就有误差了。

- ### 主析取范式和主合取范式

   主析取范式是极小项之和，主合取范式是极大项之积，主析取范式和主合取范式都是唯一的，那么相应的极小项和极大项也要为一，而极小项是且的形式，要表达结果唯一只能取真值为1，同样极大项要唯一只能取假。

   在用真值表法求主析取范式和主合取范式时，每个命题变元按照01变化展开，然后求出对应的整个命题表达式的真假值

    求主析取范式就取表达式的值为1时对应的P，Q，R的下标,比如上图第一个1对应的为001，转换成十进制就是1，即m<sub>1</sub>；第二个1是011，就是m<sub>3</sub>，那么主析取范式就是m<sub>1</sub>交m<sub>3</sub>交m<sub>4</sub>交m<sub>7</sub> ，而下标是几则对应的极小项就是输入是这个下标时极小项的命题变元组合为1的那个表达式对应的极小项。比如这里的m3对应的就是非P交Q交R。

   同样的方法表达式值为0对应的就是极大项及主合取范式。

- ### 线性组合及线性相关

   > 一组向量A可以被另一组向量B线性表示，我A是B的一个线性组合，也可以说A可以被B线性表示。
   >
   > 在[向量空间](https://baike.baidu.com/item/%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4)V的一组向量**A:** 如果存在**不全为零**的数 k1, k2, ···,km ,和向量组的每个向量相乘加起来结果是0向量，则称向量组**A**是线性相关的。如果不存在这样的一组不全为0的数，即当且仅当 k1, k2, ···,km全为0时，相乘相加才是0向量，那么我们就称A是线性无关的。

- ### 激活函数

   激活函数就是在人工神经网络上运行的函数，引入它的目的是为了增加网络模型的非线性，就是增加拟合性。

   > 如果不用激励函数，每一层输出都是上层输入的线性函数，无论神经网络有多少层，输出都是输入的线性组合，这种情况就是最原始的[感知机](https://baike.baidu.com/item/%E6%84%9F%E7%9F%A5%E6%9C%BA/12723581)（Perceptron）。
   >
   > 如果使用的话，激活函数给神经元引入了非线性因素，使得神经网络可以任意逼近任何非线性函数，这样神经网络就可以应用到众多的非线性模型中。

   [详情请点击这篇博客](https://blog.csdn.net/v_july_v/article/details/51812459)

- ### 卷积神经网络

   - 卷积层

     > 对图像（不同的数据窗口数据）和滤波矩阵（一组固定的权重：因为每个神经元的多个权重固定，所以又可以看做一个恒定的滤波器filter）做**内积**（逐个元素相乘再求和）的操作就是所谓的『卷积』操作，也是卷积神经网络的名字来源

     中间滤波器filter与数据窗口做内积，其具体计算过程则是：4✖️0 + 0✖️*0 + 0*✖️0 + 0✖️*0 + 0*✖️1 + 0✖️*1 + 0✖️*0 + 0✖️*1 + -4*✖️2 = -8。

   - 池化层

     池化，简言之，即取区域平均或最大。

- ### 机器学习

   机器学习中分为有监督、半监督和无监督学习，主要就是看给的数据中有无数据标注，也就是答案，即给个x有对应的y与之对应，事先已经完成分类或说明即完成标注。无监督学习给的数据都是未标注的，要自己找数据间的内在关系。还有就是增强学习，这个与前三类区别较大，**他是没有标注数据集的**。

   > 根据周围环境的情况（预先给出大规则），采取行动，根据采取行动的结果，学习行动方式 ，仅根据环境情况自我学习。
   >
   > 我们机器学习的算法叫做Agent .要根据周围的环境来采取行动，在我们采取了行动之后，我们的算法相应就会收到反馈，这种反馈有的时候是reward奖赏机制反馈，有的时候是惩罚机制进行反馈，不管怎样当我们Agent算法得到反馈之后，就会相应改进自己的行为模式，之后再面对环境的其他情况下根据改进的算法再做出相应的action动作，环境再反馈给我们的Agent以此类推 我们的Agent实在一轮一轮的行动反馈中组件增强自己的智能 

- ### Agent

   > 通常，我们可以把Agent理解为“个人软件代理”，Agent是一种在分布式系统或者协作系统中，能够持续自主地发挥作用的计算实体，是一个个体，简称为“智能体”。广义上，Agent指具有智能的任何实体，可以是计算机硬件和智能软件（只要你想的到它都行，嘿嘿）。

- ### 深度学习过拟合

   如果一味的为了**提高对训练数据的预测能力**，所选的模型就要不断增加复杂性，不断增加参数，最终就会导致拟合的函数完美的预测训练集，但对新数据的测试集预测结果差。 过度的拟合了训练数据，而没有考虑到泛化能力。

   通俗讲就是模型太好了，给的都能学到，由于数据集的抽样本质，那么其中不可避免就会存在有误差的数据。比如样本是X，X=x（真值）+u（随机误差），给的是X他就按照X学，但我们实际的目的是要拟合x，一直学X就会让模型泛化能力变差，即普适性降低。

- ### 域名

   是与ip地址一一映射的，为了让人们可以更方便的访问互联网可不用去记住冗余的ip地址数串。

   baidu.com.  这就是一个域名也称为一级域名或者叫顶级域名。前面加个www之后也是域名，叫做二级域名，是为了便于访问和人们的习惯。二级域名是附属于一级域名的，它的存在不影响顶级域名，它没了顶级域名依然在，但是顶级域名如果没了下属的所有二三级等域名就全都没了。

- ### cd命令

   cd+空格+文件名就可以进到当前目录下指定的文件夹里面

   cd+空格+绝对路径（即/……...）可以从绝对路径进到指定的文件夹里,即从**根文件夹**开始访问（对于本机的话就是从系统盘Macintosh HD这个总目录开始往下找，找到对应路径的文件夹就打开)

   cd然后直接回车是返回用户主目录，cd ..是返回上一级目录。

- ### 使用命令行编写并运行C++程序

   shell里直接用vim xxx.cpp新建c++文件，然后摁i进入编辑模式，写完之后摁esc退出编辑模式，输入：wq然后会车。

   之后用g++ -o xxx 文件名.cpp用来编译文件名.cpp里的代码并生成文件名为xxx的可执行文件，如果直接用g++ 文件名.cpp的话默认是生成名为a.out的可执行文件。

   然后直接用./xxx或者用./a.out即可直接运行文件输出结果。

   ### 还有一些小的技巧

   ~（潮水符号）：这是房子（home）文件夹的快捷表示。例如本机的房子文件夹是bias，那么在具体操作时就可以用～来代替/bias。例如/bias/pictures就可以用～/pictures，二者等价。

   .*<u>(点)：这代表你现在所处的文件夹位置。在上面的例子上，我们在相对路径下操作Document文件夹，我们也可以通过./Document来进行处理[在前面运行最后编译生成对文件时就用到了这个，./a.out来运行文件，其他的用途尚未得知]</u>*

- ### 集合预算的两个重要定律

   集合的分配对偶率：A∩(B∪C)=(A∩B)∪(A∩C)；A∪(B∩C)=(A∪B)∩(A∪C) 

   > 需要注意的是括号是在后面的，这样才可以分配，如果括号里的是前面连个就不能用分配对偶率了。

   集合的对偶率：(A∪B)^C=A^C∩B^C；(A∩B)^C=A^C∪B^C

   > 这里后面^C的意思是取余集，其实就是德摩根率，真是闲的蛋疼。

- ### 狄杰斯特拉算法求一个顶点到其余各定点的最短路径

   [参加csdn的一篇博客](https://blog.csdn.net/jerry81333/article/details/54772709)

- ### 接口的一些规范

   现在一般的接口分为usb type-A  usb type-B和usb type-C这些是接口的**物理规范**。

   A就是我们现在电脑，u盘和充电器数据线上常用的借口类型

   B比较奇特不常见

   C就是现在流行的接口，没有正反之分很方便

   而usb2.0/3.0/3.1是**传输协议规范**。其实3.1分为两种。usb3.1 gen1就是我们现在常用的3.0

    而usb3.1 gen2才是真正的3.1

- ### 奇偶校验

   就是在传输的数据中加上了一位校验位。选择奇校验还是偶校验是事先确定好的。

   奇校验：原始数位+校验位总共有奇数个1（就是说如果原数位有奇数个1，那么校验位就是0；同样如果数据位有偶数个1那么校验位就是1.就是无论如何确保所有位一共有奇数个1，即全部异或起来之后是1。）

   偶校验：原始数位+校验位总共有偶数个1（原理和上面的奇校验相反）

   那么检测的时候就把接收到的所有数据位全部异或，奇校验的话结果是1就代表正确，偶校验的话结果是0就代表正确。**但是这种方法只能检测出奇数个错误，由异或的原理我们可以知道偶数个错误的结果和正确情况的结果是一致的；其次它只能检测出错误但是并不能修改。**

- ### 使用终端编写java

   与c++类似，vim 文件名.java新建一个java文件，i编辑然后esc退出编辑，：wq保存之后javac 文件名.java即可编译文件，生成一个.class后缀的文件，然后java 文件名即可执行出结果（文件名必须是类名，还有就是最后执行的时候输入文件名即可不用输入.class后缀）。

- ### 路由器和交换机

   - 路由器工作在网络层，交换机工作在数据链路层
   - 路由器根据ip地址来转发ip数据报/分组，交换机是根据mac地址转发数据帧
   - 交换机主要是用来组建局域网，将不同的ip连起来；而路由器主要是用来连接外网。通过交换机组建的局域网是不能访问外网的，所有主机用的都是私网的ip，必须通过路由器转换成公网的ip之后才能访问外网。
   - 简单来说交换机共享一根网线，而路由器共享一个ip

- ### 以太网

   它并不是网，而是一种局域网技术，包括一些局域网标准和一些通讯协议。

- ### 条形码与二维码

   - 条形码又一维码，仅在水平方向记录表达信息，其高度是为了扫描器的对准
   - 二维码相对于一维码增加了垂直方向，可以表达的信息大大增加因此更广泛的使用

- ### 物联网定义

   **物联网**(The Internet of Things)的概念是在1999年提出的，它的定义很简单：把所有物品通过射频识别等信息传感设备与互联网连接起来，实现智能化识别和管理。

- ### RFID

   射频识别技术，又称无线射频识别。是物联网中常用的一种技术，是一种[通信技术](https://baike.baidu.com/item/%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF/2865397)，可通过无线电讯号识别特定目标并读写相关数据，而无需识别系统与特定目标之间建立机械或光学接触。包括三部分

   - [应答器](https://baike.baidu.com/item/%E5%BA%94%E7%AD%94%E5%99%A8)：由天线，耦合元件及芯片组成，一般来说都是用[标签](https://baike.baidu.com/item/%E6%A0%87%E7%AD%BE)作为应答器，每个标签具有唯一的电子编码，附着在物体上标识目标对象。
   - 阅读器：由天线，[耦合](https://baike.baidu.com/item/%E8%80%A6%E5%90%88)元件，芯片组成，读取（有时还可以写入）标签信息的设备，可设计为手持式rfid读写器或固定式读写器。
   - 应用软件系统 ：是应用层软件，主要是把收集的数据进一步处理，并为人们所使用。

   像我们日常使用的身份证银行卡等都用到这个技术，这个技术可以有效的的吧物品于互联网连接起来，再通过一些软件我们可以很方便的对物品进行识别和管理。

- ### 数据和信息

   data并不等于information

   数据是事实或观察的结果，是对客观事物的逻辑归纳，适用于表示客观事物的未经加工的原始材料。

   而数据根据我们的要求进行加工处理之后提炼出来的我们想要的东西就是信息。

- ### 分辨率

   分辨率，又称解析度、解像度，可以从显示分辨率与图像分辨率两个方向来分类。

   - 显示分辨率（屏幕分辨率）是屏幕[图像](https://baike.baidu.com/item/%E5%9B%BE%E5%83%8F/773234)的精密度，是指[显示器](https://baike.baidu.com/item/%E6%98%BE%E7%A4%BA%E5%99%A8/362722)所能显示的[像素](https://baike.baidu.com/item/%E5%83%8F%E7%B4%A0/95084)有多少。我们平常说的电脑显示器的分辨率多少多少说的就是这个。标准的2K分辨率为2048✖️1080，但现在主流的一些显示器所谓的2K即屏幕的显示分辨率为2560*1440或者2560✖️1660，但是这一表述不准确，鉴于分辨率达到2000像素为2K，那么上面的两种像素应该被称为2.5k更合适，而不是简单的称为2k

   - 图像分辨率则是**单位英寸中所包含的像素点数**，**即ppi**，其定义更趋近于分辨率本身的定义，它是一个固定的数值，例如dpi是72即代表单位英寸中有72个像素点，数值越大显示效果越好。

     ppi计算公式：PPI=√（X^2+Y^2）/ Z （X：长度像素数；Y：宽度像素数；Z：屏幕大小，单位英寸）。注意并不能简单认为人眼的极限ppi为300，这样忽略了人眼和屏幕距离的问题，是不符合实际的。

- ### 像素

   像素是构成位图的基本单元，当位图图像放大到一定程度时，所看到的一个一个的马赛克色块就是像素且像素色块的大小不是绝对的，会根据**<u>图像分辨率</u>**的多少而改变。**<u>当图片尺寸以像素为单位时，我们需要指定其固定的分辨率即ppi，才能将图片尺寸与现实中的实际尺寸相互转换</u>**。例如大多数网页制作常用图片分辨率为72，即每英寸像素为72，1英寸等于2.54厘米，那么通过换算可以得出每厘米等于28像素；又如15x15厘米长度的图片，等于420*420像素的长度。

   - 相机所说的像素，其实是[最大像素](https://baike.baidu.com/item/%E6%9C%80%E5%A4%A7%E5%83%8F%E7%B4%A0)的意思，像素是分辨率的单位，这个像素值仅仅是相机所支持的有效最大分辨率。

   ​       30万 640×480

   ​       50万 800×600

   - 还有一点就是我们手机屏幕的显示分辨率是固定的，那同时由于手机大小固定那么手机屏幕的图像分辨率也固定了，但手机相机照出来的照片是可以有更高的显示分辨率的，就比如我的小米mix 2s，手机屏幕分辨率为2160✖️1080，但是相机可以照出4032*3024的照片，理论上更多的像素点更清晰，但是已经超出了2160✖️1080得解读范围，最终显示还是2160✖️1080，但是照片保存的话是保存的4032✖️3024，像素大代表同一张图片以同样的ppi显示的话显示分辨率高的图片可以放的更大。

- ### 系统

   就是根据一个输出然后经过中间处理然后得出一个输出，这就是系统。

   我们做软件，做的就是中间处理那个步骤。

- ### 聚类和分类的关系

   - 对于分类来说，在对数据集分类时，我们是知道这个数据集是有多少种类的，比如对一个学校的在校大学生进行性别分类，我们会下意识很清楚知道分为“男”,“女”

   - 而对于聚类来说，在对数据集操作时，我们是不知道该数据集包含多少类，我们要做的，是将数据集中相似的数据归纳在一起。比如预测某一学校的在校大学生的好朋友团体，我们不知道大学生和谁玩的好玩的不好，我们通过他们的相似度进行聚类，聚成n个团体，这就是聚类。

     按照李春葆老师的话说，聚类是将数据对象的集合分成相似的对象类的过程。使得同一个簇（或类）中的对象之间具有较高的相似性，而不同簇中的对象具有较高的相异性

     ```
     分类是提前确定有多少个种类，然后分类标准是什么，然后开始分。
     而聚类提前什么都不知道，然后将相似性高的数据聚在一起。
     ```

- ### 并行与并发

   ​     什么是并发?（交替执行）

> 并发:指应用能够交替执行不同的任务,例:吃完饭->喝水 喝完水->睡觉 一觉醒来继续吃饭     

​             什么是并行?（同时执行）

> 并行:指应用能够同时执行不同的任务,例:吃饭的时候可以边吃饭边打电话,这两件事情可以同时执行

- ```
  两者区别:并发是交替执行,并行是同时执行.例如一个CPU处理两个任务，同一时间只能处理一个，那么A用10分钟然后B再用10分钟然后再循环，这个就是并发执行。那么我有了2个CPU，同时处理A和B，这就叫并行。
  ```

- ### 进程process和线程thread

  进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.
  线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.

  简而言之,一个程序至少有一个进程,一个进程至少有一个线程.

  > 开个QQ，开了一个进程；开了迅雷，开了一个进程。在QQ的这个进程里，传输文字开一个线程、传输语音开了一个线程、弹出对话框又开了一个线程。所以运行某个软件，相当于开了一个进程。在这个软件运行的过程里（在这个进程里），多个工作支撑的完成QQ的运行，那么这“多个工作”分别有一个线程。所以一个进程管着多个线程。通俗的讲：“进程是爹妈，管着众多的线程儿子”.

- ### where和which

  which这条命令主要是用来查找系统PATH目录下的可执行文件。说白了就是查找那些我们已经安装好的可以直接执行的命令

  where这个命令可以用来查找二进制（命令）、源文件、man文件。与which不同的是这条命令可以是通过文件索引数据库而非PATH来查找的，所以查找的面比which要广。

- ### 闭包（计算机编程语言）

  - 计算机编程语言中的闭包**(即函数内部再定义的一个函数)**
    - 闭包是一个能够访问其他函数作用域的函数。
    - 即闭包是一个函数，这个函数不仅能访问自己的作用域，更关键的是还可以访问其他函数。
    - 只要在一个函数中再定义一个函数，这个内部函数就是一个闭包。
  - 数学上的闭包和计算机编程语言的闭包不是一个概念，二者不一样，描述起来较为复杂，emmmmmmm。

- ### 重载函数

  同一个函数名，但参数不一样，系统会根据你输入的参数类型或者参数的个数来判断要点用的函数。

  比如计算两数之和，整型和浮点型如果分开写的要写不同名的两个函数。但用重载函数的话就可以写两个重名的函数，只要参数类型或个数不一样就行，程程序执行会自动根据参数类型选择对应的函数。

  int-sum（int a，int b）

  float-sum（float a，float b）

  这两个就可以用函数重载

  sum（int a，int b）

  sum（float a，float b）

  这样不用记住众多不同名字的函数，记住一个sum就可以，只要参数类型或个数不一样就行

- ### API

  应用程序编程接口，其实就是通道，本质是一些预先定义的函数。让应用程式开发人员得以呼叫一组[例程](https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6))功能，而无须考虑其底层的原始码为何、或理解其内部工作机制的细节

  例如软件A想调用软件B的一些功能但又不想看B的源码和了解B的代码组成和功能，就可以通过B的API来实现，这些可以用B的功能而无需考虑源码。

- ### 密钥

  密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为对称密钥与非对称密钥。

- ### C++中的using namespace std；

  这是一个名称空间编译指令，std这个名称空间中包含着c++编译器的标准组件：类，函数和变量。如果没有用这个命令的话，cout就是std：：cout，所以直接用using namespace std，这个using编译命令使得std名称空间中的所有名称都可用，但这是一种偷懒的做法，跟好的方法是只使要用到的名称可用，通过使用using声明来实现 

  using std::cout   //make cout available

  using std::cin     //make cin available

- ### 编译的过程

  - 预处理。g++  -E  test.cpp  -o  test.i

    处理宏定义和头文件。将原文件test.cpp扩展为test.i文件

  - 编译。    g++  -S  test.i**(也可以用g++ -S test.cpp直接把.cpp变成test.s)**

    将c++代码转换为汇编代码。将预处理输出文件test.i会变成test.s

  - 汇编。    g++  -c  test.s**(同理也可以直接g++ -c test.cpp直接编译生成test.o)**

    将汇编语言翻译成机器指令。将汇编文件test.s变成test.o文件

  - 链接。   g++  test.o  -o  test

    将.o文件与.lib库文件链接生成可执行文件。生成可执行文件test

    