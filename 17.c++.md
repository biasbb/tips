- ### static

  1. 局部变量（函数内部）

     - 普通局部变量。即为在函数内部定义的变量，编译器不会对其进行初始化。存储于进程栈空间，使用完立刻释放内存。
     - 静态局部变量。在前面加了个static，如果声明时未赋初值，编译器会自动初始化为０。同时它存储于进程的全局数据区，即使函数返回，它的值也保持不变，直到程序运行结束。**可以在循环时担当计数器**。

  2. 全局变量

     - 普通全局变量。定义在函数体外，全局存储，如果无初值编译器会自动对其初始化为0。对整个工程可见，其他文件想用它加个extern声明一下就可以访问，但是不能再定义和它重名的。
     - 静态全局变量。声明时未赋初值，编译器会自动初始化为０。只在当前文件可见，其他文件可以定义与他同名的，互不影响。

  3. 静态函数

     与静态全局变量类似，只在本文件中可见而且其他文件可以使用重名函数，互不影响。

     ------

  4. 类的静态数据成员

     - 存储在全局数据区

     - 只有一个拷贝，一个对象对他修改那么所有的全改了

     - **类的普通数据成员只能在类内定义时初始化或者通过对象x初始化。但是类的静态数据成员只能通过类名初始化，初始化用<数据类型><类名>::<静态数据成员名>=<值>**

     - 访问的话类名和对象名都可以，但是普通数据成员只能通过对象。

     - 可以作为类的成员函数的默认参数，但是普通的不行

       ```c++
       class A
       {
         public:
         int x;
         static int y;
         void add(int z=y)   //可以，但是int z=x不行
         {
           return z+1;
         }  
       ```

  5. 类的静态成员函数

     - **只能访问类的静态数据成员或静态成员函数，而不能访问普通数据成员和普通成员函数。**
     - 非静态成员函数可以任意地访问静态成员函数和静态数据成员。

- ### 不同文件之间读取

  c++源文件A.cpp想读取另一个源文件B.cpp的函数int add(int x)：

  1. 直接调用。在调用之前加一个声明
  
     B.cpp
  
     ```c++
     int add(int x)
     {
       return x+1;
     }
     ```
  
     A.cpp
  
     ```c++
     #include"iostream"
     using namespace std;
     
     int main()
     {
       int add(int x);
       cout<<add(1);      //结果输出2
       return 0;
     }
     ```
  
  2. 头文件引用。B.cpp的代码不变，函数体仍然在B.cpp中，创建一个和B.cpp同名的头文件B.h，将函数声明写在头文件中
  
     B.h
  
     ```c++
     #ifndef UNTITLED_H_H
     #define UNTITLED_H_H
     
     int add(int x);
     #endif //UNTITLED_H_H   //是自动生成的三行，是防止头文件重复引用的，代码写到他们中间就行。
     ```
  
     A.cpp
  
     ```c++
     #include"iostream"
     #include"B.h"        //导入头文件B.h
     using namespace std;
     
     int main()
     {
       cout<<add(1);      //结果输出2
       return 0;
     }
     ```
  
  > 两种方式可以达到同样的结果，其实第二种的#include"B.h"在预处理的时候做的操作是把B.h的代码以文本形式复制过来，其实本质上和第一种一样。
  >
  > 最好用第二种方式，文件清晰明了，整齐，便于管理
  
- ### 参数传递的两种方式
  
  - 值传。函数操作的是实参值的一个拷贝，操作完之后实参值并不变。
  
  - 引用传。函数操作的是实参的引用，即实参的别名，操作完之后实参值也变了。
  
    ```c++
    int swap(int x,int y)
    {
        int temp=0;
        temp=x;
        x=y;
        y=temp;
        return 0;
    }
    int main()
    {
        int a=1,b=2;
        swap(a,b);
        cout<<a<<" "<<b<<endl;
        return 0;
    }
    //运行完之后结果是1、2，a、b的值并没有交换就因为swap函数操作的是a、b的值的拷贝，但如果用引用传值的话就可以了
    int swap(int &x,int &y)
    {
        int temp=0;
        temp=x;
        x=y;
        y=temp;
        return 0;
    
    }
    int main()
    {
        int a=1,b=2;
        swap(a,b);
        cout<<a<<" "<<b<<endl;
        return 0;
    }
    //这样的话结果就是2、1了，函数参数是引用，调用的时候相当于int &x=a，对x操作就是对a操作
    ```
  
-  ### 字符数组和字符串数组
  
  - 定义字符数组就用下面两种方法，而且char*定义的时候不需要写长度和中括号，更简洁。
  
    char a[]="……."（**括号里可以预先不写大小，初始化会自动分配大小）**或者char *a="…..."
  
    调用的时候直接用数组或者指针的名字就可以代表整个字符串。
  
    例如
  
    char a[3]="my"；和char *b="my"；效果是一样的，cout<<a和cout<<b都会输出“my”
  
  - 定义字符串数组和字符数组类似
  
    char a[] [10]={"….","…..."}**（这块第二个括号里必须写数字，就是最大字符串的大小，第一个可以不写，调用的时候就当成二维数组就可以**）或者char *a[]={"……..","……..."}**（调用的时候和前面的一样当成二维数组直接写数字就可以）**
  
  - 但是整型数组将不一样了,int a[]和int *a效果是不一样的，而且不能用数组名代替整个数组，数组名只能代表数组首元素的地址并不能代表全部数组
  
    主要是因为cout的原因
  
- ### Public，private和protected

  这里说的类外其实就是类对象，因为就算public的成员函数在类外访问也只能通过类对象

  - 访问控制修饰符

    - public:对所有的都可见，类内类外都可以。

    - protected：对其派生类和友元类的成员函数可见，即派生类和友元类的成员函数可以访问它；对其他不可见，包括类对象，类对象想访问保护成员只能先用类的public成员函数访问保护成员，然后类对象再访问public成员函数。

    - private：对本类的成员函数及友元类的成员函数可以访问，子类不可见

      > protected和private的区别就是protected多了个可被派生类访问

  - 继承方式

    - public：父类的public和protected成员到了子类中仍是子类的public和protected成员，子类内成员函数可以直接访问，但是子类对象只能访问public不能访问protected。父类的私有成员子类不可见
    - protected：父类的public和protected成员到了子类变成了子类的protected成员，子类内的成员函数可以直接访问，子类对象统统不能访问。父类的私有成员对子类不可见。
    - private：父类的public和protected到了子类变成了子类的private成员，只有子类的成员函数可以访问，类对象不行。父类的private对子类不可见

- ### stl中的begin和end

  vector的的begin指向开头第一个元素，但是end是指向末尾元素的下一个位置，并不是最后一个元素，使用迭代器输出时可以明显看到，迭代器只想begin()时就是第一个元素，但是指向end()时会输出一个很大的数，应该时下一位置的地址，指向end()-1时才会输出最后一个元素，**即是左闭右开区间**
  
- ### Typeid获取数据类型

  获取变量或表达式占用的字节数，用sizeof函数

  获取变量或表达式的数据类型用typeid操作符，要配合name()函数一起使用，因为typeid是操作符，返回的是系统库类对象的一个引用

  ```c++
  #include "iostream"
  #include "typeinfo"
  using namespace std;
  
  int main()
  {
      int c=1;
      cout<< typeid(c).name();
  }
  ```

  输出结果是i，表示是int型

  **i 表示int，b=bool c=char  s=short  l=long f=float, d=double x=long long** 

  **注意添加头文件**：`#include"typeinfo"`
  在上头文件中定义了typeid()操作符可以输出变量的类型。

- ### 位域

  - 概念

    类和结构**可以包含比1个变量声明时的类型占用更小空间的**成员（声明变量时声明的数据类型，如果声明是int型，那么位域可以占比一个int即4字节更小的空间）。 这些成员被指定为位域。

    位域是一种特殊的**类数据成员（结构体数据成员）**，用于保存特定的位数

  - 定义

    在成员名后面加一个冒号以及指定位数的**常量表达式**，指出成员是一个位域

  eg：

  ```c++
  struct{
          unsigned int a ;
          unsigned int b ;
      } i;      //size(i)是8,因为i中两个int变量，两个4
  ```

  但是如果用位域

  ```c++
   struct{
          unsigned int a : 1;
          unsigned int b : 4;
      } i;      //就表示i有两个位域成员，a和b
                //size(i)是4,a和b的位数之后没有超过一个int的32位；一旦他们的位数之和超过了32位，那就要再用一个int，size(i)即为8
  ```

- ### 宏定义和内联函数

  - 宏定义

    ```
    #define 标识符 字符串
    ```

    用来将一个标识符(宏名)定义为一个字符串，该标识符被称为宏名，被定义的字符串称为替换文本。程序编译之前的预处理阶段所有的宏名都会被定义的字符串替换，这便是宏替换，发生在预处理也叫做预编译阶段。

    >优点：
    >
    >1. 提高了程序的可读性，同时也方便进行修改；
    >
    >2. 提高程序的运行效率：使用带参的宏定义既可完成函数调用的功能，又能避免函数的出栈与入栈操作，减少系统开销，提高运行效率；
    >3. 宏是由预处理器处理的，通过字符串操作可以完成很多编译器无法实现的功能。比如##连接符。
    >
    >缺点：
    >
    >1. 由于是直接嵌入的，所以代码可能相对多一点；
    >
    >2. 嵌套定义过多可能会影响程序的可读性，而且很容易出错；
    >
    >3. 对带参的宏而言，由于是直接替换，并不会检查参数是否合法，存在安全隐患。

  - inline

    在函数定义的时候前面加上inline关键字，就变成了内联函数。在编译时将函数体展开，发生在编译过程中，因此可以进行诸如类型安全检查、语句是否正确等编译功能。

    > inline函数一般用于比较小的，频繁调用的函数，这样可以减少函数调用带来的开销

  - 不同点

    - inline是函数展开，而宏只是简单的文本替换
    - 宏定义在预处理阶段，而inline是编译阶段。因此后者可以安全检查
    - 宏定义时后面的宏参数最好用括号括起来防止出现二义性，而inline不会

- ### 函数模板

  属于泛函编程，即不考虑数据类型，有点像动态语言

  ```c++
  template <typename A>
  A function(A a,A b)
  {
    return a+b;
  }
  ```

  其中的A并不是一个具体的数据类型，而是泛指任意数据类型，这儿就把他看作是A型。

  **调用函数模板时可以自动推导数据类型，例如上面的，调用时用function(1,2)那么就会自动推导A为int。也可以显示指定。**

  显示指定就function<int>(a,b)

  > 用的时候最好显示指定好参数的数据类型

- ### 函数指针和指针函数

  - 函数指针即指向函数的指针

    ```c++
    int (*p)(int ,int );
    p=f;    //f即函数名
    ---
    typedf int (*P)(int ,int );
    P p=f;
    ```

    前面的int是函数的返回类型，后面是函数的形参的数据类型

    赋值时直接赋值函数名即可，因为函数名就表示函数的地址

    ```c++
    int a(int x,int y)
    { 
      return x+y;
    }
    int (*p)(int ,int);
    p=a;
    //调用的时候就
    (*p)(1,2); //等价于a(1,2)
    ```

    **函数指针可以作为函数参数传递给函数，类似于python的高阶函数**

    ```c++
    int test1(int a)
    {
      return a-1;
    }
    int test2(int (*p)(int),int y)
    {
      return (*p)(10)+y;
    }
    int main()
    {
      int (*p)(int);
      p=test1;
      cout<<test2(p,2)<<endl;
      return 0;
    }
    //结果即为11
    ```

    **函数指针数组**

    ```c++
    void a()
    {
      cout<<'a'<<endl;
    }
    void b()
    {
      cout<<'b'<<endl;
    }
    void c()
    {
      cout<<'c'<<endl;
    }
    typedf void (*P)(void);
    P f[]={a,b,c};  //f即为函数指针数组
    f[0]();  //即调用a函数，等价于a();
    ```

  - 指针函数即函数的返回值是一个指针

    int*  p(int x,int y）
  
- #### #和##

  都是用在宏定义中。

  - `#`的作用是将宏参数**不经扩展的**转换成字符串**常量**(不能再修改，和const一样）。

    ```c++
    #define F abc  
    #define B def  
    #define FB(arg) #arg  
    #define FB1(arg) FB(arg)  
    #include"iostream"
    using namespace std;
    
    int main()
    {
      cout<<FB(F B)<<end;    
      cout<<FB1(F B)<<endl;   
      return 0;
    }  
    ```

    第一行输出为`F B`，因为是不经扩展 地转换所以没有用上面的宏定义换。变换过程为FB(F B) -> #F B ->"F B"

    第二行输出为`abc def`，转换过程为FB1(F B) ->FB1(abc def) ->FB(abc def) -> #(abc def) ->"abc def"

  - `##`的是连接操作符。将出现在其左右的字符序列合并成一个变量名

    ```c++
    #define F(x)  x##ias
    #include "iostream"
    using namespace std;
    int main()
    {
        int bias=1;
        F(b)+=1;
        cout<<bias;      //F(b)其实就相当于是bias的引用，因此输出为2
        return 0;
    }
    ```

- #### c++堆和栈

   C++程序的5种内存存储区（**注意程序没有运行时是不会占用内存的，但是程序在编译的时候就会分配好到时候谁占哪儿，所以这儿说的内存占用其实是编译器规划好的内存使用方案**）

  - 栈区：局部变量，函数传参值，自动释放，效率高但内存少
  - 堆区：malloc函数从堆上申请内存，用free释放内存，若不释放，程序结束释放
  - 自由存储区：自由存储区是C++基于new操作符的一个抽象概念。new操作符在此申请内存，用delete释放内存，若不释放，程序结束释放
  - 全局/静态区：存储全局变量或静态变量。内存在编译时就分配好了（程序执行前），整个程序运行期间都存在，程序结束时释放。
  - 常量存储区：存储常量（const），不允许修改。

  **注意：**

  **（1）堆是c语言和操作系统的术语，是操作系统维护的一块内存。自由存储是C++中通过new和delete动态分配和释放对象的抽象概念。
  （2）new所申请的内存区域在C++中称为自由存储区，编译器用malloc和free实现new和delete操作符时，new申请的内存可以说是在堆上。
  （3）堆和自由内存区有相同之处，但并不等价。<u>自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存</u>**

  ---

  **栈和堆主要的区别**

  - 堆由程序员控制（通过malloc/free，new/delete），内存动态分配（就是要多少给多少），是不连续的内存区域，大小受限于计算机的有效内存（32位即4G）。因此更灵活，但是因为灵活度大容易造成内存泄漏。通过new和malloc由低到高分配，由delete或free手动释放或者程序结束自动释放。
  - 栈由编译器自动管理，静态分配，是一块连续的内存区域，大小是操作系统预定好的。由高到低，由编译器自动分配释放。

- #### malloc/free和new/delete区别

  - new/new[]用法

    ```c++
    int *p=new int;     //开辟sizeof(int)的空间，即4字节，没有赋初值那就初始化为0.注意这儿开辟的空间是p指向的空间
    cout<<*p;           //输出0
    cout<<sizeof(*p);   //输出4，*p为p指向的空间
    cout<<siezeof(p);   //输出8，因为64位系统，那么指针表示地址，就需要64位二进制数即8字节
    int *q=new int(5);  //开辟sizeof（int）的空间，并初始化为5
    --------------------
    int *a=new int[100]{0};  //开辟大小为100个int的整形数组，并初始化为0.没有赋初值那就初始化为0
    int (*a)[6]=new int[5][6]; //二维数组
    int (*a)[5][6]=new int[3][5][6]; //三维数组
    ```

  - delete/delete[]

    ```c++
    int *a=new int;
    delete a;
    ---------------
    int *a new int[10];
    delete []a;
    ```

  使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。

  而且malloc默认是范围void*类型，还需要加强制转换

  malloc不能初始化，而new可以赋初值

  ```
  int *p1 = (int*)malloc(sizeof(int));  
  ```

  #### Summary

  |        特征        |              new/delete               |             malloc/free              |
  | :----------------: | :-----------------------------------: | :----------------------------------: |
  |   分配内存的位置   |              自由存储区               |                  堆                  |
  | 内存分配失败返回值 |             完整类型指针              |                void*                 |
  | 内存分配失败返回值 |             默认抛出异常              |               返回NULL               |
  |   分配内存的大小   |       由编译器根据类型计算得出        |          必须显式指定字节数          |
  |      处理数组      |       有处理数组的new版本new[]        | 需要用户计算数组的大小后进行内存分配 |
  |  已分配内存的扩充  |            无法直观地处理             |         使用realloc简单完成          |
  |    是否相互调用    | 可以，看具体的operator new/delete实现 |             不可调用new              |
  | 分配内存时内存不足 | 客户能够指定处理函数或重新制定分配器  |       无法通过用户代码进行处理       |
  |      函数重载      |                 允许                  |                不允许                |
  | 构造函数与析构函数 |                 调用                  |                不调用                |

  malloc给你的就好像一块原始的土地，你要种什么需要自己在土地上来播种

  ![img](./image/29.jpg)

  而new帮你划好了田地的分块（数组），帮你播了种（构造函数），还提供其他的设施给你使用:

  ![img](image/30.jpg)

  当然，malloc并不是说比不上new，它们各自有适用的地方。在C++这种偏重OOP的语言，使用new/delete自然是更合适的。

- 
