- ### 多态

  c++的多态即派生类对象的地址可以赋值给基类[指针](http://c.biancheng.net/c/80/)。对于通过基类指针调用基类和派生类中都有的同名、同参数表的虚函数的语句，编译时并不确定要执行的是基类还是派生类的虚函数；而当程序**运行**到该语句时，如果基类指针指向的是一个基类对象，则基类的虚函数被调用，如果基类指针指向的是一个派生类对象，则派生类的虚函数被调用。这种机制就叫作“多态（polymorphism）

  **多态可以简单地理解为同一条函数调用语句能调用不同的函数；或者说，对不同对象发送同一消息，使得不同对象有各自不同的行为。**

  ```c++
  #include "iostream"
  using namespace std;
  class A
  {
  public:
      virtual void Output()
      {
          cout<<"A"<<endl;
      }
  };
  class B:public A
  {
  public:
      virtual void Output()
      {
          cout<<"B"<<endl;
      }
  };
  int main()
  {
      A *a=new A();
      A *b=new B();
      a->Output();
      b->Output();
      return 0;
  }
  ```
  
  结果为A，B。就看基类指针指向的的基类还是子类的对象，是谁的对象就调用谁的虚函数。
  
  但是如果没有定义虚函数的话，那么就不存在多态了，两个都会调用基类的成员函数，输出Ａ。
  
- ### static

  1. 局部变量（函数内部）

     - 普通局部变量。即为在函数内部定义的变量，编译器不会对其进行初始化。存储于进程栈空间，使用完立刻释放内存。
     - 静态局部变量。在前面加了个static，如果声明时未赋初值，编译器会自动初始化为０。同时它存储于进程的全局数据区，即使函数返回，它的值也保持不变，直到程序运行结束。**可以在循环时担当计数器**。

  2. 全局变量

     - 普通全局变量。定义在函数体外，全局存储，如果无初值编译器会自动对其初始化。对整个工程可见，其他文件可以使用extern来访问，但是不能再定义和它重名的。
     - 静态全局变量。只在当前文件可见，其他文件可以定义与他同名的，互不影响。

  3. 静态函数

     与静态全局变量类似，只在本文件中可见而且其他文件可以使用重名函数，互不影响。

     ------

  4. 静态数据成员

     - 存储在全局数据区
     - 只有一个拷贝，一个对象对他修改那么所有的全改了
     - 初始化只能用<数据类型><类名>::<静态数据成员名>=<值>
     - 访问的话类名和对象名都可以

  5. 静态成员函数

     - 只能访问类的静态数据成员或静态成员函数，而不能访问普通数据成员和普通成员函数。
     - 非静态成员函数可以任意地访问静态成员函数和静态数据成员。

- ### 不同文件之间读取

  c++中从一个源文件想读取另一个源文件的函数：

  1. 直接调用。在调用之前加一个声明，例如file.cpp中有个int A()函数，那么file1.cpp想调用那个函数的话就先声明，即先int A();然后下一行直接A();即实现调用。
  2. 将函数的声明写在另一个头文件file2.h里，调用的时候直接引用头文件然后就可以直接调用。
  
- ### 参数传递的两种方式
  
  - 值传。函数操作的是实参值的一个拷贝，操作完之后实参值并不变。
  
  - 引用传。函数操作的是实参的引用，即实参的别名，操作完之后实参值也变了。
  
    ```c++
    int swap(int x,int y)
    {
        int temp=0;
        temp=x;
        x=y;
        y=temp;
        return 0;
    }
    int main()
    {
        int a=1,b=2;
        swap(a,b);
        cout<<a<<" "<<b<<endl;
        return 0;
    }
    //运行完之后结果是1、2，a、b的值并没有交换就因为swap函数操作的是a、b的值的拷贝，但如果用引用传值的话就可以了
    int swap(int &x,int &y)
    {
        int temp=0;
        temp=x;
        x=y;
        y=temp;
        return 0;
    
    }
    int main()
    {
        int a=1,b=2;
        swap(a,b);
        cout<<a<<" "<<b<<endl;
        return 0;
    }
    //这样的话结果就是2、1了，函数参数是引用，调用的时候相当于int &x=a，对x操作就是对a操作
    ```
  
-  ### 字符数组和字符串数组
  
  - 定义字符数组就用下面两种方法，而且char*定义的时候不需要写长度和中括号，更简洁。
  
    char a[]="……."（**括号里可以预先不写大小，初始化会自动分配大小）**或者char *a="…..."
  
    调用的时候直接用数组或者指针的名字就可以代表整个字符串。
  
    例如
  
    char a[3]="my"；和char *b="my"；效果是一样的，cout<<a和cout<<b都会输出“my”
  
  - 定义字符串数组和字符数组类似
  
    char a[] [10]={"….","…..."}**（这块第二个括号里必须写数字，就是最大字符串的大小，第一个可以不写，调用的时候就当成二维数组就可以**）或者char *a[]={"……..","……..."}**（调用的时候和前面的一样当成二维数组直接写数字就可以）**
  
  - 但是整型数组将不一样了,int a[]和int *a效果是不一样的，而且不能用数组名代替整个数组，数组名只能代表数组首元素的地址并不能代表全部数组
  
    主要是因为cout的原因
  
- ### Public，private和protected

  这里说的类外其实就是类对象，因为就算public的成员函数在类外访问也只能通过类对象

  - 访问控制修饰符

    - public:对所有的都可见，类内类外都可以。

    - protected：对其派生类和友元类的成员函数可见，即派生类和友元类的成员函数可以访问它；对其他不可见，包括类对象，类对象想访问保护成员只能先用类的public成员函数访问保护成员，然后类对象再访问public成员函数。

    - private：对本类的成员函数及友元类的成员函数可以访问，子类不可见

      > protected和private的区别就是protected多了个可被派生类访问

  - 继承方式

    - public：父类的public和protected成员到了子类中仍是子类的public和protected成员，子类内成员函数可以直接访问，但是子类对象只能访问public不能访问protected。父类的私有成员子类不可见
    - protected：父类的public和protected成员到了子类变成了子类的protected成员，子类内的成员函数可以直接访问，子类对象统统不能访问。父类的私有成员对子类不可见。
    - private：父类的public和protected到了子类变成了子类的private成员，只有子类的成员函数可以访问，类对象不行。父类的private对子类不可见

- 字符串的最后面会跟一个\0，是字符串结束的标志，读字符串当遇到\0的时候就停，读取结束。但是是不可见的，不在s.size()里，就是一个标志

- ### stl中的begin和end

  vector的的begin指向开头第一个元素，但是end是指向末尾元素的下一个位置，并不是最后一个元素，使用迭代器输出时可以明显看到，迭代器只想begin()时就是第一个元素，但是指向end()时会输出一个很大的数，应该时下一位置的地址，指向end()-1时才会输出最后一个元素，**即是左闭右开区间**
  
- ### Typeid获取数据类型

  获取变量或表达式占用的字节数，用sizeof函数

  获取变量或表达式的数据类型用typeid操作符，要配合name()函数一起使用，因为typeid是操作符，返回的是系统库类对象的一个引用

  ```c++
  #include "iostream"
  #include "typeinfo"
  using namespace std;
  
  int main()
  {
      int c=1;
      cout<< typeid(c).name();
  }
  ```

  输出结果是i，表示是int型

  **i 表示int，b=bool c=char  s=short  l=long f=float, d=double x=long long** 

  **注意添加头文件**：`#include"typeinfo"`
  在上头文件中定义了typeid()操作符可以输出变量的类型。

- ### 位域

  - 概念

    类和结构**可以包含比整数类型占用更小空间的**成员。 这些成员被指定为位域。

    位域是一种特殊的**类数据成员（结构体数据成员）**，用于保存特定的位数

  - 定义

    在成员名后面加一个冒号以及指定位数的**常量表达式**，指出成员是一个位域

  eg：

  ```c++
  struct{
          unsigned int a ;
          unsigned int b ;
      } i;      //size(i)是8,因为i中两个int变量，两个4
  ```

  但是如果用位域

  ```c++
   struct{
          unsigned int a : 1;
          unsigned int b : 4;
      } i;      //就表示i有两个位域，a和b
                //size(i)是4,a和b的位数之后没有超过一个int的32位；一旦他们的位数之和超过了32位，那就要再用一个int，size(i)即为8
  ```

- ### 宏定义和内联函数

  - 宏定义

    ```
    #define 标识符 字符串
    ```

    用来将一个标识符(宏名)定义为一个字符串，该标识符被称为宏名，被定义的字符串称为替换文本。程序编译之前，编译的时候所有的宏名都会被定义的字符串替换，这便是宏替换，发生在预处理也叫做预编译阶段。

    >优点：
    >
    >1. 提高了程序的可读性，同时也方便进行修改；
    >
    >2. 提高程序的运行效率：使用带参的宏定义既可完成函数调用的功能，又能避免函数的出栈与入栈操作，减少系统开销，提高运行效率；
    >3. 宏是由预处理器处理的，通过字符串操作可以完成很多编译器无法实现的功能。比如##连接符。
    >
    >缺点：
    >
    >1. 由于是直接嵌入的，所以代码可能相对多一点；
    >
    >2. 嵌套定义过多可能会影响程序的可读性，而且很容易出错；
    >
    >3. 对带参的宏而言，由于是直接替换，并不会检查参数是否合法，存在安全隐患。

  - inline

    在函数定义的时候前面加上inline关键字，就变成了内联函数。在编译时将函数体展开，发生在编译过程中，因此可以进行诸如类型安全检查、语句是否正确等编译功能。

    > inline函数一般用于比较小的，频繁调用的函数，这样可以减少函数调用带来的开销

  - 不同点

    - inline是函数展开，而宏只是简单的文本替换
    - 宏定义在预处理阶段，而inline是编译阶段。因此后者可以安全检查
    - 宏定义时后面的宏参数最好用括号括起来防止出现二义性，而inline不会

- ### 函数模板

  属于泛函编程，即不考虑数据类型，有点像动态语言

  ```c++
  template <typename A>
  A function(A a,A b)
  {
    return a+b;
  }
  ```

  其中的A并不是一个具体的数据类型，而是泛指任意数据类型，这儿就把他看作是A型。

  **调用函数模板时可以自动推导数据类型，例如上面的，调用时用function(1,2)那么就会自动推导A为int。也可以显示指定。**

  显示指定就function<int>(a,b)

  > 用的时候最好显示指定好参数的数据类型

- 
