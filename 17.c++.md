- ### 多态

  c++的多态即派生类对象的地址可以赋值给基类[指针](http://c.biancheng.net/c/80/)。对于通过基类指针调用基类和派生类中都有的同名、同参数表的虚函数的语句，编译时并不确定要执行的是基类还是派生类的虚函数；而当程序**运行**到该语句时，如果基类指针指向的是一个基类对象，则基类的虚函数被调用，如果基类指针指向的是一个派生类对象，则派生类的虚函数被调用。这种机制就叫作“多态（polymorphism）

  **多态可以简单地理解为同一条函数调用语句能调用不同的函数；或者说，对不同对象发送同一消息，使得不同对象有各自不同的行为。**

  ```c++
  #include "iostream"
  using namespace std;
  class A
  {
  public:
      virtual void Output()
      {
          cout<<"A"<<endl;
      }
  };
  class B:public A
  {
  public:
      virtual void Output()
      {
          cout<<"B"<<endl;
      }
  };
  int main()
  {
      A *a=new A();
      A *b=new B();
      a->Output();
      b->Output();
      return 0;
  }
  ```
  
  结果为A，B。就看基类指针指向的的基类还是子类的对象，是谁的对象就调用谁的虚函数。
  
  但是如果没有定义虚函数的话，那么就不存在多态了，两个都会调用基类的成员函数，输出Ａ。
  
- ### static

  1. 局部变量（函数内部）

     - 普通局部变量。即为在函数内部定义的变量，编译器不会对其进行初始化。存储于进程栈空间，使用完立刻释放内存。
     - 静态局部变量。在前面加了个static，如果声明时未赋初值，编译器会自动初始化为０。同时它存储于进程的全局数据区，即使函数返回，它的值也保持不变，直到程序运行结束。**可以在循环时担当计数器**。

  2. 全局变量

     - 普通全局变量。定义在函数体外，全局存储，如果无初值编译器会自动对其初始化。对整个工程可见，其他文件可以使用extern来访问，但是不能再定义和它重名的。
     - 静态全局变量。只在当前文件可见，其他文件可以定义与他同名的，互不影响。

  3. 静态函数

     与静态全局变量类似，只在本文件中可见而且其他文件可以使用重名函数，互不影响。

     ------

  4. 静态数据成员

     - 存储在全局数据区
     - 只有一个拷贝，一个对象对他修改那么所有的全改了
     - 初始化只能用<数据类型><类名>::<静态数据成员名>=<值>
     - 访问的话类名和对象名都可以

  5. 静态成员函数

     - 只能访问类的静态数据成员或静态成员函数，而不能访问普通数据成员和普通成员函数。
     - 非静态成员函数可以任意地访问静态成员函数和静态数据成员。

- ### 不同文件之间读取

  c++中从一个源文件想读取另一个源文件的函数：

  1. 直接调用。在调用之前加一个声明，例如file.cpp中有个int A()函数，那么file1.cpp想调用那个函数的话就先声明，即先int A();然后下一行直接A();即实现调用。
  2. 将函数的声明写在另一个头文件file2.h里，调用的时候直接引用头文件然后就可以直接调用。
  
- ### 参数传递的两种方式
  
  - 值传。函数操作的是实参值的一个拷贝，操作完之后实参值并不变。
  
  - 引用传。函数操作的是实参的引用，即实参的别名，操作完之后实参值也变了。
  
    ```c++
    int swap(int x,int y)
    {
        int temp=0;
        temp=x;
        x=y;
        y=temp;
        return 0;
    }
    int main()
    {
        int a=1,b=2;
        swap(a,b);
        cout<<a<<" "<<b<<endl;
        return 0;
    }
    //运行完之后结果是1、2，a、b的值并没有交换就因为swap函数操作的是a、b的值的拷贝，但如果用引用传值的话就可以了
    int swap(int &x,int &y)
    {
        int temp=0;
        temp=x;
        x=y;
        y=temp;
        return 0;
    
    }
    int main()
    {
        int a=1,b=2;
        swap(a,b);
        cout<<a<<" "<<b<<endl;
        return 0;
    }
    //这样的话结果就是2、1了，函数参数是引用，调用的时候相当于int &x=a，对x操作就是对a操作
    ```
  
-  ### 字符数组和字符串数组
  
  - 定义字符数组就用下面两种方法，而且char*定义的时候不需要写长度和中括号，更简洁。
  
    char a[]="……."（**括号里可以预先不写大小，初始化会自动分配大小）**或者char *a="…..."
  
    调用的时候直接用数组或者指针的名字就可以代表整个字符串。
  
    例如
  
    char a[3]="my"；和char *b="my"；效果是一样的，cout<<a和cout<<b都会输出“my”
  
  - 定义字符串数组和字符数组类似
  
    char a[] [10]={"….","…..."}**（这块第二个括号里必须写数字，就是最大字符串的大小，第一个可以不写，调用的时候就当成二维数组就可以**）或者char *a[]={"……..","……..."}**（调用的时候和前面的一样当成二维数组直接写数字就可以）**
  
  - 但是整型数组将不一样了,int a[]和int *a效果是不一样的，而且不能用数组名代替整个数组，数组名只能代表数组首元素的地址并不能代表全部数组
  
    主要是因为cout的原因
  
- ### Public，private和protected

  这里说的类外其实就是类对象，因为就算public的成员函数在类外访问也只能通过类对象

  - 访问控制修饰符

    - public:对所有的都可见，类内类外都可以。

    - protected：对其派生类和友元类的成员函数可见，即派生类和友元类的成员函数可以访问它；对其他不可见，包括类对象，类对象想访问保护成员只能先用类的public成员函数访问保护成员，然后类对象再访问public成员函数。

    - private：对本类的成员函数及友元类的成员函数可以访问，子类不可见

      > protected和private的区别就是protected多了个可被派生类访问

  - 继承方式

    - public：父类的public和protected成员到了子类中仍是子类的public和protected成员，子类内成员函数可以直接访问，但是子类对象只能访问public不能访问protected。父类的私有成员子类不可见
    - protected：父类的public和protected成员到了子类变成了子类的protected成员，子类内的成员函数可以直接访问，子类对象统统不能访问。父类的私有成员对子类不可见。
    - private：父类的public和protected到了子类变成了子类的private成员，只有子类的成员函数可以访问，类对象不行。父类的private对子类不可见

- 字符串的最后面会跟一个\0，是字符串结束的标志，读字符串当遇到\0的时候就停，读取结束。但是是不可见的，不在s.size()里，就是一个标志

- ### stl中的begin和end

  vector的的begin指向开头第一个元素，但是end是指向末尾元素的下一个位置，并不是最后一个元素，使用迭代器输出时可以明显看到，迭代器只想begin()时就是第一个元素，但是指向end()时会输出一个很大的数，应该时下一位置的地址，指向end()-1时才会输出最后一个元素，**即是左闭右开区间**

